require('dotenv').config();
const {
  Client, GatewayIntentBits, ModalBuilder, TextInputBuilder, TextInputStyle,
  ActionRowBuilder, Events, REST, Routes, SlashCommandBuilder,
  ButtonBuilder, ButtonStyle, MessageFlags, EmbedBuilder, StringSelectMenuBuilder, StringSelectMenuOptionBuilder
} = require('discord.js');

const { performance } = require('node:perf_hooks'); // Add this line
const fetch = (...args) => import('node-fetch').then(({default: f}) => f(...args));

const { GoogleGenerativeAI } = require('@google/generative-ai');

const fs = require('fs').promises;
const path = require('path');

// Near the top of render index.txt
const { getAuth, signInWithCustomToken, getIdToken } = require("firebase/auth");

const userExperimentSetupData = new Map(); // To temporarily store data between modals

// ====== ENVIRONMENT VARIABLES ======
const APPLICATION_ID = process.env.APPLICATION_ID;
const DISCORD_TOKEN = process.env.DISCORD_TOKEN;
const GUILD_ID = process.env.GUILD_ID;
const SCRIPT_URL = process.env.SCRIPT_URL;

// Add to your environment variables section
const GEMINI_API_KEY = process.env.GEMINI_API_KEY;

// Add this block after your initial require statements

const { initializeApp } = require("firebase/app");
const { getFunctions, httpsCallable } = require("firebase/functions"); // Ensure this is imported

const inspirationalMessages = [
  "Congratulations on recording your metrics! 🎊\n\nNotice how you feel as if it's the first time you've ever felt this way.",
  "Amazing work logging your progress! 🌟\n\nEach moment of awareness builds a bridge to deeper understanding.",
  "Thank you for sharing your ratings! 🙏\n\nEvery data point tells a story of growth.\nWhat passage did you write today?",
  "Thank you for your forward steps! 💫\n\nLike footprints in the sand, each entry marks your path.",
  "Beautiful reflection! 🌅\n\nIn the quiet space between thoughts,\nwisdom grows like mushrooms.",
  "You've noted your progress! 🍃\n\nmay your awareness move with grace.",
  "What a mindful moment! 🕊️\n\nIn measuring our days,\nwe live bigger lives.",
  "Thanks for dotting this data point! 🌈\n\nEach rating is a window\ninto the landscape of your experience.",
  "You care courageously. 🌺\n\nWatch how your awareness grows,\nlike garden seeds planted with intention.",
  "You've planted your daily marker! ⭐\n\nYour efforts are like a constellation,\neach point shining with possibility.",
  "Reflection reflected! 🌙\n\nThe gentle rhythm of daily practice,\nshows our deepest insights.",
  "Progress snapshot captured! 🦋\n\nLike a butterfly's flap,\nyour growth can change the weather.",
  "What mindful metrics! 🎯\n\nYou've earned this moment of reflection.",
  "Like morning dew on grass,\nmay your insights meet the morning sun.",
  "A moment of truth! 🔮\n\nSelf-reflection is a mirror.\nWhat clarity do you see today?",
  "Each mindful pause creates space\nfor deeper understanding to emerge.",
  "You've written today's sentence! 📖\n\nWhat themes are surfacing\nin the story of your growth?",
  "That reflection is rippling! 💧\n\nLike stones thrown in water,\nyour awareness creates waves.",
  "Illumination! 🌠\n\nIn the darkness of uncertainty,\neach data point is a star to guide us home.",
  "Mindful milestone marked! 🎭\n\nBehind the numbers and metrics,\nwhat truth is revealing itself to you?",
  "You're amazing! \n\nYou know that?\nYOU ARE AMAZING!",
  "Nothing great was ever done but in little steps.",
  "Your life is bigger than it seems. \nToday made a difference.",
  "Consistency is the glue of growth. \nIncremental progress is all it takes!",
  "Don't be surprised when good things happen \n\nYou're putting in the work!"
];

const experimentSetupMotivationalMessages = [
  "🎉 Awesome! Your new experiment is locked in. Daily logging is your renewable fuel!",
  "✨ Experiment set! Remember, every small step contributes to big discoveries and improvements.",
  "🚀 You're all set to explore! What insights will this next phase bring? Excited for you!",
  "🎯 New experiment configured! This is your lab, and you're the lead scientist. Go get that data!",
  "🌟 Great job setting up your experiment! Embrace the process and deep learning ahead."
];

const FREEZE_ROLE_BASENAME = '❄️ Freezes';
const STREAK_MILESTONE_ROLE_NAMES = [
  'Originator', 'Mover', 'Navigator', 'Signal', 'Centurion',
  'Vector', 'Blaster', 'Corona', 'Luminary', 'Orbiter',
  'Radiance', 'Pulsar', 'Quantum', 'Zenith', 'Nexus',
  'Paragon', 'Supernova', 'Axiom', 'Oracle', 'Divinator',
  'Cosmic', 'Infinity', 'Transcendent'
];

// --- New Custom IDs for Reminder Setup ---
const REMINDER_SELECT_START_HOUR_ID = 'reminder_select_start_hour';
const REMINDER_SELECT_END_HOUR_ID = 'reminder_select_end_hour';
const REMINDER_SELECT_FREQUENCY_ID = 'reminder_select_frequency';
const REMINDER_SELECT_TIME_H_ID = 'reminder_select_time_h';
const REMINDER_SELECT_TIME_M_ID = 'reminder_select_time_m';
const REMINDER_SELECT_TIME_AP_ID = 'reminder_select_time_ap';
const CONFIRM_REMINDER_BTN_ID = 'confirm_reminder_btn';
const REMINDERS_NEXT_STEP_BTN_ID = 'reminders_next_step_btn';

// --- Default Reminder Messages (Editable Array) ---
const defaultReminderMessages = [
    "⏰ Gentle reminder to count your inputs!",
    "Hey! How's your experiment going today? Any small steps available now?",
    "Just checking in - have you counted anything yet today?",
    "📊 Making data points? Remember to count your metrics!",
    "You wanted a reminder to hit your inputs. Here you go!",
    "Today is a new day! Every moment is a choice for tomorrow!",
    "Friendly nudge to think about your experiment inputs for the day!",
    "Got any momentum? Keep it going!",
    "Unlock insights later by getting your inputs in today ✨",
    "How's your experiment today? Any space to contribute to it?",
];
// You can add/edit messages in this array later. The backend function
// 'setExperimentSchedule' will need to be aware if it should use these
// or if it has its own internal default logic when customReminderMessage is null.

// ====== FIREBASE CLIENT CONFIGURATION ======
// Load config from .env file
const firebaseConfig = {
  apiKey: process.env.FIREBASE_API_KEY,
  authDomain: process.env.FIREBASE_AUTH_DOMAIN,
  projectId: process.env.FIREBASE_PROJECT_ID,
  storageBucket: process.env.FIREBASE_STORAGE_BUCKET,
  messagingSenderId: process.env.FIREBASE_MESSAGING_SENDER_ID,
  appId: process.env.FIREBASE_APP_ID,
  measurementId: process.env.FIREBASE_MEASUREMENT_ID // Optional
};

// ===== ADD THIS LOGGING BLOCK =====
console.log("--- Firebase Config Check ---");
console.log("API Key Loaded:", !!process.env.FIREBASE_API_KEY);
console.log("Auth Domain Loaded:", !!process.env.FIREBASE_AUTH_DOMAIN);
console.log("Project ID Loaded:", !!process.env.FIREBASE_PROJECT_ID);
// Log the actual values to be sure, but be mindful if sharing logs later
console.log("Using Project ID:", process.env.FIREBASE_PROJECT_ID);
console.log("Using API Key:", process.env.FIREBASE_API_KEY ? process.env.FIREBASE_API_KEY.substring(0, 5) + '...' : 'MISSING'); // Log start of API key
console.log("Full Config Object being used:", JSON.stringify(firebaseConfig, null, 2));
console.log("-----------------------------");
// ===== END LOGGING BLOCK =====

// Check if all required config values are present
const requiredConfigKeys = ['apiKey', 'authDomain', 'projectId', 'FIREBASE_FUNC_URL_GET_TOKEN']; // Added function URL check
const missingKeys = requiredConfigKeys.filter(key => !process.env[key] && !firebaseConfig[key]); // Check process.env directly too for URL

let firebaseApp;
let firebaseAuth;
let firebaseFunctions;

if (missingKeys.length > 0) {
  console.warn(`⚠️ Firebase client or function URL configuration incomplete. Missing keys in .env: ${missingKeys.join(', ')}. Firebase features may fail.`);
} else {
  try {
    // Initialize Firebase Client App
    firebaseApp = initializeApp(firebaseConfig);
    firebaseAuth = getAuth(firebaseApp); // Get Auth instance
    firebaseFunctions = getFunctions(firebaseApp); // Get Functions instance (uses default region)
    // Optional: Specify region if your functions aren't in us-central1
    // firebaseFunctions = getFunctions(firebaseApp, 'your-region');
    console.log("Firebase Client App Initialized.");
  } catch (error) {
    console.error("❌ Failed to initialize Firebase Client App:", error);
    // Consider exiting if Firebase is critical
    // process.exit(1);
  }
}

// ====== Corrected Helper Function for Firebase Authentication =====
// Fetches custom token via HTTPS and signs in user with Firebase client SDK
async function authenticateFirebaseUser(userId) {
  // Ensure auth client is initialized and function URL is present
  const functionUrl = process.env.FIREBASE_FUNC_URL_GET_TOKEN;
  if (!firebaseAuth || !functionUrl) {
      console.error("Firebase auth not initialized or FIREBASE_FUNC_URL_GET_TOKEN missing in .env.");
      throw new Error("Firebase client auth/config not ready.");
  }

  // Use node-fetch v3 syntax correctly - scoped import
  const fetch = (...args) => import('node-fetch').then(({ default: f }) => f(...args));
  let customTokenResponse;

  try {
      // STEP 1: Directly fetch the custom token using the Function URL
      console.log(`Requesting custom token for userId: ${userId} directly from ${functionUrl}`);
      customTokenResponse = await fetch(functionUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          // v2 onCall expects data wrapped in { data: ... }
          body: JSON.stringify({ data: { userId: userId } })
      });

      // Check if the fetch itself was successful
      if (!customTokenResponse.ok) {
          const errorText = await customTokenResponse.text();
          console.error(`Error fetching custom token directly: ${customTokenResponse.status}`, errorText);
          // Throw the specific error text if available
          throw new Error(`Failed to fetch custom token (${customTokenResponse.status}): ${errorText}`);
      }

      // Parse the JSON response
      const tokenResult = await customTokenResponse.json();

      // v2 onCall wraps the actual return value in { "result": ... }
      const customToken = tokenResult.result?.token;

      if (!customToken) {
        console.error("Custom token missing from direct function response:", JSON.stringify(tokenResult));
        throw new Error('Custom token was not returned from the getFirebaseAuthToken function.');
      }
      // console.log(`Custom token received directly for user ${userId}.`); // Optional log

      // STEP 2: Sign in with Custom Token using the Firebase client SDK
      // console.log(`Signing in user ${userId} with custom token...`); // Optional log
      await signInWithCustomToken(firebaseAuth, customToken);
      // console.log(`User ${userId} signed in successfully to Firebase client.`); // Optional log

      // No need to return anything, the auth state is handled by the SDK instance

  } catch (error) {
    console.error(`Firebase authentication process failed for user ${userId}:`, error);
    // Re-throw error to be caught by callFirebaseFunction or command handler
    throw new Error(`Firebase authentication failed: ${error.message || error}`);
  }
}

// ===== Helper Function for Calling Firebase Callable Functions ====
// Wraps authentication and the function call
async function callFirebaseFunction(functionName, data = {}, userId) {
    // Ensure Functions client is initialized
    if (!firebaseFunctions) {
        console.error("Firebase Functions client not initialized. Cannot call function.");
        // Throw an error that can be caught by the command handler
        throw new Error("Firebase connection not ready. Please try again later.");
    }
    try {
        // Ensure user is authenticated for this specific call
        // authenticateFirebaseUser handles logging and throws errors on failure
        await authenticateFirebaseUser(userId);

        console.log(`Calling Firebase function: ${functionName} by user ${userId} with data:`, data);
        // Get a reference to the callable function
        const func = httpsCallable(firebaseFunctions, functionName);
        // Call the function with the provided data payload
        const result = await func(data);
        console.log(`Received response from ${functionName} for user ${userId}.`); // Don't log result.data here as it might be large/sensitive

        // Callable functions return the result in the 'data' property of the response object
        return result.data;

    } catch (error) {
        console.error(`Error calling Firebase function ${functionName} for user ${userId}:`, error);
        // Check if it's a Firebase Functions error object (which includes code/message)
        if (error.code && error.message) {
             // Re-throw with a cleaner message for the user-facing error handler
             throw new Error(`Firebase Error (${error.code}): ${error.message}`);
        }
        // Re-throw other types of errors (e.g., network errors, auth errors from helper)
        throw error;
    }
}

/**
 * Sends a final summary DM and prompts the user to post publicly.
 * @param {import('discord.js').Interaction} interaction - The interaction to reply to (usually Button or ModalSubmit)
 * @param {object} setupData - The data stored in userExperimentSetupData
 * @param {string} reminderSummary - Text describing the reminder setup ("Reminders skipped", "Reminders set for...")
 * @param {string[]} motivationalMessagesArray - Array of motivational messages
 */
async function showPostToGroupPrompt(interaction, setupData, reminderSummary, motivationalMessagesArray) {
  const userId = interaction.user.id; // Get userId for cleanup
  const randomMotivationalMessage = motivationalMessagesArray[Math.floor(Math.random() * motivationalMessagesArray.length)];

  // --- Build the Comprehensive DM Embed ---
  const dmEmbed = new EmbedBuilder()
      .setColor('#57F287') // Green for success
      .setTitle('🎉 Experiment Setup Complete! 🎉')
      .setDescription(`${randomMotivationalMessage}\n\nHere's the final summary of your new experiment. Good luck!`)
      .addFields(
          // Field 1: Deeper Problem (from setupData)
          { name: '🎯 Deeper Problem', value: setupData.deeperProblem || 'Not specified' },
          // Field 2: Initial Settings Summary (use the message from Firebase stored earlier)
          // We need to extract the *core* settings part from the result message stored previously
          // Or reconstruct it from rawPayload if simpler
           { name: '📋 Initial Settings', value: `Output: "${setupData.outputLabel}"\nInput 1: "${setupData.input1Label}"${setupData.input2Label ? `\nInput 2: "${setupData.input2Label}"`:''}${setupData.input3Label ? `\nInput 3: "${setupData.input3Label}"`:''}` },
         // { name: '📋 Initial Settings', value: setupData.settingsMessage.split('\n\n')[1] || 'Could not parse settings summary.' }, // Example parsing, adjust as needed based on Firebase message format
          // Field 3: Duration (from setupData)
          { name: '🗓️ Experiment Duration', value: `${setupData.experimentDuration.replace('_', ' ')} (Stats report interval)` },
          // Field 4: Reminders (passed as argument)
          { name: '⏰ Reminders', value: reminderSummary }
      )
      .setFooter({ text: `User: ${interaction.user.tag}`})
      .setTimestamp();
  // --- End Embed Build ---

  try {
      // Send the DM
      await interaction.user.send({ embeds: [dmEmbed] });
      console.log(`[showPostToGroupPrompt ${interaction.id}] Sent final summary DM to ${interaction.user.tag}`);
  } catch (dmError) {
      console.error(`[showPostToGroupPrompt ${interaction.id}] Failed to send DM confirmation to ${interaction.user.tag}:`, dmError);
      // Optionally try to inform user in the ephemeral message if DM fails
      // Non-critical, proceed with ephemeral prompt
  }

  // --- Show Ephemeral "Post to group?" Buttons ---
  const postToGroupButtons = new ActionRowBuilder()
      .addComponents(
          new ButtonBuilder().setCustomId('post_exp_final_yes').setLabel('📣 Yes, Post It!').setStyle(ButtonStyle.Success),
          new ButtonBuilder().setCustomId('post_exp_final_no').setLabel('🤫 No, Keep Private').setStyle(ButtonStyle.Secondary)
      );

  // Edit the reply from the previous step (reminder modal submit or skip button)
  try {
       // Check if we can editReply (it should be possible as the interaction was deferred/updated)
       if (interaction.replied || interaction.deferred) {
            await interaction.editReply({
               content: `✨ Your experiment is fully configured! I've just DMed you the final summary.\n\n**Share your commitment with the #experiments channel?**`,
               components: [postToGroupButtons],
               embeds: [] // Clear any previous ephemeral embeds
           });
           console.log(`[showPostToGroupPrompt ${interaction.id}] Edited reply with post-to-group prompt.`);
       } else {
            // Fallback if somehow the interaction wasn't replied/deferred (less likely)
            await interaction.reply({
                content: `✨ Your experiment is fully configured! I've just DMed you the final summary.\n\n**Share your commitment with the #experiments channel?**`,
                components: [postToGroupButtons],
                flags: MessageFlags.Ephemeral
            });
            console.log(`[showPostToGroupPrompt ${interaction.id}] Replied with post-to-group prompt (fallback).`);
       }
  } catch (promptError) {
       console.error(`[showPostToGroupPrompt ${interaction.id}] Error showing post-to-group prompt:`, promptError);
       // Attempt a followup if editReply failed
       try {
           await interaction.followUp({
               content: `✨ Experiment configured & summary DMed! Failed to show post prompt buttons.`,
               flags: MessageFlags.Ephemeral
           });
       } catch (followUpError) {
           console.error(`[showPostToGroupPrompt ${interaction.id}] Error sending follow-up error message:`, followUpError);
       }
  }
  // Note: userExperimentSetupData cleanup happens *after* the Yes/No buttons are handled.
}


// End of Firebase initialization and helper functions block
// Your existing bot code (const client = new Client(...), etc.) starts below this

// ====== Global Error Handlers ======
process.on('unhandledRejection', (reason, promise) => {
  console.error('🔥 Unhandled Rejection at:', promise, 'reason:', reason);
  process.exit(1);
});

process.on('uncaughtException', err => {
  console.error('💥 Uncaught Exception thrown:', err);
  process.exit(1);
});

// Add near other constants/env vars
const INSIGHTS_COOLDOWN = 0 //3600000; // 1 hour in milliseconds
const userInsightsCooldowns = new Map();

// Initialize Gemini with error handling
let genAI;
try {
  genAI = new GoogleGenerativeAI(GEMINI_API_KEY);
} catch (error) {
  console.error('Failed to initialize Gemini:', error);
}

// Add Gemini configuration here
const GEMINI_CONFIG = {
  temperature: 0.8,
  topK: 50,
  topP: 0.95,
  maxOutputTokens: 1024
};

// Add this function to test the AI integration
async function testGeminiAPI() {
  try {
    console.log("Starting testGeminiAPI");
    
    if (!genAI) {
      console.error("genAI not initialized. GEMINI_API_KEY:", 
        GEMINI_API_KEY ? "present" : "missing");
      throw new Error('Gemini AI not initialized');
    }

    console.log("Creating model instance");
    const model = genAI.getGenerativeModel({ model: "gemini-1.5-pro" });
    
    const prompt = "Generate a short test response: What's the best thing about keeping a daily log?";
    console.log("Sending test prompt:", prompt);
    
    const result = await model.generateContent(prompt);
    console.log("Raw result:", result);
    
    const response = await result.response;
    console.log("Response object:", response);
    
    const text = response.text();
    console.log("Final text:", text);
    
    return {
      success: true,
      message: text
    };
  } catch (error) {
    console.error('Detailed Gemini API test error:', {
      error: error.toString(),
      stack: error.stack,
      message: error.message
    });
    return {
      success: false,
      error: error.message
    };
  }
}

/*
const QUEUE_CONFIG = {
  BATCH_SIZE: 10,
  BATCH_DELAY: 1000, // 1 second between batches
  MAX_RETRIES: 3,
  RETRY_DELAY: 5000  // 5 seconds between retries
};
*/

// ====== REGISTER SLASH COMMANDS ======
const rest = new REST({ version: '10' }).setToken(DISCORD_TOKEN);
(async () => {
  try {
    await rest.put(
      Routes.applicationGuildCommands(APPLICATION_ID, GUILD_ID),
      { body: [
        new SlashCommandBuilder()
          .setName('testlog')
          .setDescription('Preview how your daily log will look')
          .toJSON(),
        new SlashCommandBuilder()
          .setName('streak')
          .setDescription('Check your current streak')
          .toJSON(),        
        new SlashCommandBuilder()
        .setName('testai')
        .setDescription('Test the AI integration')
        .toJSON(),
        // Add this to your slash commands array in the registration section
        new SlashCommandBuilder()
          .setName('go')
          .setDescription('Self Science Hub')
          .toJSON()
      ]}
    );
    console.log('Slash commands registered.');
  } catch (error) {
    console.error('Error registering slash commands:', error);
  }
})();

async function generateInsights(structuredData) {
  console.log("🧠 generateInsights received:", JSON.stringify(structuredData, null, 2));
  try {
    const model = genAI.getGenerativeModel({ model: "gemini-1.5-pro" });
    const prompt = INSIGHTS_PROMPT_TEMPLATE(structuredData); // Pass the data to the template function

   const result = await model.generateContent(prompt);
    const response = await result.response;
    const text = response.text();
    
    // Maximum possible length while staying under Discord's 2000 limit
    const MAX_LENGTH = 1999;
    const finalText = text.length > MAX_LENGTH 
      ? text.substring(0, MAX_LENGTH) + "..."
      : text;

    return {
      success: true,
      insights: finalText,
      metadata: {
        generatedAt: new Date().toISOString(),
        dataPoints: structuredData.priorities.length,
        periodDays: structuredData.userMetrics.periodDays
      }
    };
  } catch (error) {
    console.error('Error generating insights:', error);
    return {
      success: false,
      error: error.message
    };
  }
}


const INSIGHTS_PROMPT_TEMPLATE = (data) => {
  // Helper to format a single stats summary for the prompt (No changes needed here)
  const formatSummary = (summary, index) => {
    // Basic check if summary object is valid
    if (!summary || typeof summary !== 'object') return `  Summary ${index + 1}: Not Available\n`;
    const generatedDateObj = summary.summaryGeneratedAt ? new Date(summary.summaryGeneratedAt) : null;
    const generatedDate = generatedDateObj instanceof Date && !isNaN(generatedDateObj) ? generatedDateObj.toLocaleDateString() : 'Unknown Date';
    let text = `  Summary ${index + 1} (Generated: ${generatedDate}):\n`;
    if (summary.priorities && Array.isArray(summary.priorities) && summary.priorities.length > 0) {
      summary.priorities.forEach(p => {
        if (p && typeof p === 'object') {
          const metrics = p.metrics || {};
          text += `    - ${p.label || 'N/A'} (${p.unit || 'N/A'}): Avg ${metrics.average ?? 'N/A'}, Var ${metrics.variation ?? 'N/A'}%\n`;
        }
      });
    } else { text += `    - No priority stats available for this summary.\n`; }
    if (summary.correlations && Array.isArray(summary.correlations) && summary.correlations.length > 0) {
      text += `    - Correlations vs Satisfaction:\n`;
      summary.correlations.forEach(c => {
         if (c && typeof c === 'object') { text += `      * ${c.priority || 'N/A'}: ${c.interpretation || 'N/A'}\n`; }
      });
    }
    return text;
  };

  // Safely access data (No changes needed here)
  const userMetrics = data?.userMetrics || {};
  const periodDays = userMetrics.periodDays || 'Unknown';
  const currentStreak = userMetrics.currentStreak ?? 0;
  const longestStreak = userMetrics.longestStreak ?? 0;
  const notes = data?.notes || [];
  const pastSummaries = data?.pastFourStatsSummaries || [];

  // Construct the prompt with refined instructions
  return `Analyze the user's habit tracking data (last ${periodDays} logs) with a supportive, growth-focused tone. The goal is to provide insights that inspire the user to continue their journey of consistent small actions and encourage thoughtful experimentation with tweaks to make these actions easier and more impactful. Keep the total response concise (under 1890 characters).

Data Overview:
- User Metrics: Current Streak ${currentStreak}, Longest ${longestStreak}
- Period Analyzed: ${periodDays} logs, ending ${new Date().toLocaleDateString()}
- Last 4 Weekly Stats Summaries (Newest First):
${(pastSummaries.length > 0)
  ? pastSummaries.map(formatSummary).join('\n')
  : '  No past stats summaries available.'
}
- Notes from the last ${periodDays} logs:
${(notes.length > 0)
  ? notes.map(n => `  • ${n?.date || 'Unknown Date'}: ${n?.content || ''}`).join('\n')
  : '  No notes available for this period.'
}

// This replaces the part starting "Provide analysis in three sections:"
// in the INSIGHTS_PROMPT_TEMPLATE function in index.js

Provide analysis in three sections:

### 🫂 Challenges & Consistency
Review their journey, focusing on friction points and consistency patterns across the weekly summaries and notes.
- Pinpoint recurring friction points or areas where consistency fluctuates, using both notes and weekly summary data (e.g., high metric variation).
- **If possible, connect these friction points directly to specific phrases or feelings the user expressed in their notes around that time.** (e.g., 'The lower consistency for [Metric X] around [Date] might relate to when you mentioned feeling "[Quote from note]"').
- Notice patterns in their consistency: *When* do they seem most consistent or inconsistent according to the data and notes?
- Where does their effort seem persistent, even if results vary? Validate this effort clearly.
- Acknowledge any struggles mentioned with compassion and normalize their struggles as part of the experimentation process.

### 🌱 Growth Highlights
Highlight evidence of growth, adaptation, and the impact of sustained effort by analyzing patterns across the 4 summaries and notes. Start by celebrating their consistency (mention current streak if known) and the most significant positive trend or achievement observed.
- Are priorities or their measured outcomes (average, variation) trending positively or negatively across the weeks? How has their focus evolved (e.g., changes in tracked priority labels/units visible in summaries)?
- Point out any potentially interesting (even if subtle) connections observed between metric trends and themes found in the notes.
- Look for subtle shifts in language in notes, "hidden wins" (e.g., maintaining effort despite challenges), or emerging positive patterns that signal progress.
- **Also, select 1-2 particularly insightful or representative short quotes directly from the provided 'Notes' that capture a key moment of learning, challenge, or success during this period, and weave them into your analysis where relevant (citing the date if possible).**
- How are their consistent small actions leading to evolution, as seen in the weekly data and reflections?

### 🧪 Experiments & Metaphor
Remember, small, sustainable adjustments often lead to the biggest long-term shifts. Suggest 2-3 small, actionable experiments (tweaks) for the upcoming week, designed to make their current positive actions easier, more consistent, or slightly more impactful, based on the analysis above. Frame these as curious explorations, not fixes. Experiments should aim to:
1. Build on momentum from positive trends or consistent efforts identified in the 'Growth Highlights' section.
2. Directly address the friction points or consistency challenges identified in the 'Challenges' section by suggesting small modifications.
3. **Prioritize suggesting experiments that directly explore questions, ideas, or 'what ifs' explicitly mentioned in the user's recent notes.** (Quote the relevant part of the note briefly if it helps frame the experiment).
4. Focus on *adjustments* to existing routines/habits rather than introducing entirely new, large habits.

**Finally, conclude with a single, concise metaphor *that specifically reflects the key challenge or transformation discussed in this user's analysis*. *If possible, subtly draw inspiration for the metaphor's theme from recurring concepts or tones found in the user's notes.* ** (Examples: "Your journey this month feels like a sculptor refining their work..." or "You've been like a scientist carefully adjusting variables...").

Keep the total response under 1890 characters.`;
};

// >>>>> End of replacement block <<<<<


// ====== DISCORD CLIENT ======
const client = new Client({ intents: [GatewayIntentBits.Guilds] });

client.once(Events.ClientReady, () => {
  console.log(`Logged in as ${client.user.tag}`);
  
  /*
  // Process queue immediately on startup
  processMessageQueue().catch(console.error);
  
  // Then set up the interval (every 3 minutes)
  setInterval(() => {
    processMessageQueue().catch(console.error);
  }, 3 * 60 * 1000);
*/

});

/*
async function processMessageQueue() {
  try {
    console.log('Starting queue check...');
    console.log('SCRIPT_URL:', SCRIPT_URL);
    
    const requestBody = {
      action: 'getQueuedMessages'
    };
    console.log('Request body:', JSON.stringify(requestBody));

    const response = await fetch(SCRIPT_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(requestBody)
    });
    
    console.log('Response status:', response.status);
    const responseText = await response.text();
    console.log('Raw response:', responseText);
    
    const result = JSON.parse(responseText);
    console.log('Parsed response:', result);
    
    if (!result.messages?.length) {
      console.log('No messages in queue');
      return;
    }

    console.log(`Processing ${result.messages.length} messages in queue`);

    // Process messages in batches
    for (let i = 0; i < result.messages.length; i += QUEUE_CONFIG.BATCH_SIZE) {
      const batch = result.messages.slice(i, i + QUEUE_CONFIG.BATCH_SIZE);
      console.log(`Processing batch ${Math.floor(i/QUEUE_CONFIG.BATCH_SIZE) + 1}`);
      
      for (const msg of batch) {
        try {
          console.log(`Attempting to deliver message ${msg.id} to user ${msg.userTag}`);
          const user = await client.users.fetch(msg.userId);
          await user.send(msg.message);
          console.log('Message sent successfully');
          
          // Confirm delivery
          console.log(`Confirming delivery for message ${msg.id}`);
          const confirmResponse = await fetch(SCRIPT_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              action: 'confirmDelivery',
              messageId: msg.id
            })
          });

          const confirmText = await confirmResponse.text();
          console.log('Confirmation response:', confirmText);
          
          const confirmResult = JSON.parse(confirmText);
          console.log('Parsed confirmation result:', confirmResult);

          if (!confirmResult.success) {
            throw new Error('Failed to confirm delivery: ' + (confirmResult.error || 'Unknown error'));
          }
          
          console.log(`Successfully delivered and confirmed message to ${msg.userTag}`);

        } catch (error) {
          console.error(`Failed to process message ${msg.id}:`, error);
          
          try {
            console.log(`Reporting failure for message ${msg.id}`);
            await fetch(SCRIPT_URL, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                action: 'deliveryFailed',
                messageId: msg.id,
                error: error.message
              })
            });
            console.log(`Reported delivery failure for ${msg.userTag}`);
          } catch (reportError) {
            console.error('Failed to report message delivery failure:', reportError);
          }
        }
      }
    }
  } catch (error) {
    console.error('Error in message queue processing:', error);
  }
}
*/

// ====== INTERACTION HANDLER ======
client.on(Events.InteractionCreate, async interaction => {

          // --- START: ADD THIS NEW SECTION ---
    const interactionId = interaction.id; // Get the unique ID for this specific interaction event
    console.log(`\n--- InteractionCreate START [${interactionId}] ---`);
    console.log(`[${interactionId}] Timestamp: ${new Date().toISOString()}`);
    console.log(`[${interactionId}] Type: ${interaction.type}, Constructor: ${interaction.constructor.name}, User: ${interaction.user?.tag}`);
    if (interaction.isModalSubmit()) {
        console.log(`[${interactionId}] Modal Custom ID: ${interaction.customId}`);
    } else if (interaction.isButton()) {
        console.log(`[${interactionId}] Button Custom ID: ${interaction.customId}`);
    } else if (interaction.isChatInputCommand()){
        console.log(`[${interactionId}] Command Name: ${interaction.commandName}`);
    }
    // --- END: ADD THIS NEW SECTION ---

  console.log(`[NEW TEST] Top of InteractionCreate: typeof interaction.showModal = ${typeof interaction.showModal}, constructor: ${interaction.constructor.name}`);
  const interactionStartTime = performance.now();

  console.log(`[NEW TEST] Interaction received. Type: ${interaction.type}, Constructor: ${interaction.constructor.name}`);
  if (interaction.constructor.name === 'ModalSubmitInteraction') {
    console.log(`[NEW TEST] For ModalSubmit: typeof interaction.showModal = ${typeof interaction.showModal}`);
    // Let's see what methods it *does* have from a typical Interaction
    console.log(`[NEW TEST] For ModalSubmit: typeof interaction.reply = ${typeof interaction.reply}`);
    console.log(`[NEW TEST] For ModalSubmit: typeof interaction.deferReply = ${typeof interaction.deferReply}`);
    console.log(`[NEW TEST] For ModalSubmit: typeof interaction.editReply = ${typeof interaction.editReply}`);
    console.log(`[NEW TEST] For ModalSubmit: typeof interaction.followUp = ${typeof interaction.followUp}`);
    console.log(`[NEW TEST] For ModalSubmit: typeof interaction.isModalSubmit = ${typeof interaction.isModalSubmit}`); // Should be true
    // Log the object itself to inspect its structure. This might be very verbose.
    // Consider if you want to do this, as it might flood your console.
    // console.log('[NEW TEST] Raw ModalSubmitInteraction object:', interaction);
  } else if (interaction.constructor.name === 'ButtonInteraction') {
     console.log(`[NEW TEST] For Button: typeof interaction.showModal = ${typeof interaction.showModal}`);
  }

  console.log(`⚡ Received interaction:`, {
    type: interaction.type,
    isCommand: interaction.isChatInputCommand?.(),
    command: interaction.commandName,
    user: interaction.user?.tag
  });

  if (interaction.isChatInputCommand()) {
    try {
      const commandStartTime = performance.now();
      console.log(`[${interaction.commandName}] Command processing started at: ${commandStartTime.toFixed(2)}ms (Delta from interaction start: ${(commandStartTime - interactionStartTime).toFixed(2)}ms)`);
      switch (interaction.commandName) {

        case 'testlog': {
          const modal = new ModalBuilder()
            .setCustomId('testLogPreview')
            .setTitle('Daily Log Preview');

          modal.addComponents(
            new ActionRowBuilder().addComponents(
              new TextInputBuilder()
                .setCustomId('priority1')
                .setLabel('Priority 1 (Measurement or Effort Rating)')
                .setStyle(TextInputStyle.Short)
                .setPlaceholder('e.g. "Meditation, 15 mins"')
                .setRequired(true)
            ),
            new ActionRowBuilder().addComponents(
              new TextInputBuilder()
                .setCustomId('priority2')
                .setLabel('Priority 2 (Measurement or Effort Rating)')
                .setStyle(TextInputStyle.Short)
                .setPlaceholder('e.g. "Focus, 8/10 effort"')
                .setRequired(true)
            ),
            new ActionRowBuilder().addComponents(
              new TextInputBuilder()
                .setCustomId('priority3')
                .setLabel('Priority 3 (Measurement or Effort Rating)')
                .setStyle(TextInputStyle.Short)
                .setPlaceholder('e.g. "Writing, 500 words"')
                .setRequired(true)
            ),
            new ActionRowBuilder().addComponents(
              new TextInputBuilder()
                .setCustomId('satisfaction')
                .setLabel('Satisfaction (0-10)')
                .setStyle(TextInputStyle.Short)
                .setRequired(true)
            ),
            new ActionRowBuilder().addComponents(
              new TextInputBuilder()
                .setCustomId('notes')
                .setLabel('Notes / Experiment / Good & Bad')
                .setStyle(TextInputStyle.Paragraph)
                .setRequired(true)
            )
          );

          return await interaction.showModal(modal);
        }


        case 'streak': {
          // Defer reply to acknowledge the command quickly
          await interaction.deferReply({ flags: MessageFlags.Ephemeral });

          try {
            // Call the new Firebase function using your helper
            // The 'callFirebaseFunction' helper handles authentication.
            // 'getStreakData' is the name of the function you added to functions/index.js
            // No data payload is needed for getStreakData, so we pass an empty object {}.
            console.log(`[/streak] Calling getStreakData Firebase function for User: ${interaction.user.id}`);
            const result = await callFirebaseFunction(
              'getStreakData',   // Name of the Firebase function
              {},                // No data payload needed for this function
              interaction.user.id  // Pass the interacting user's ID
            );
            console.log(`[/streak] Received response from getStreakData:`, result);

            // Check if the Firebase function was successful and returned a message
            if (result && result.success === true && typeof result.message === 'string') {
              await interaction.editReply({
                content: result.message, // Display the message from the Firebase function
                // flags: MessageFlags.Ephemeral is already set by deferReply
              });
            } else {
              // Handle cases where the function might not return success:true or a message
              console.error(`[/streak] getStreakData function call did not return expected success or message. Result:`, result);
              await interaction.editReply({
                content: "❌ Could not retrieve your streak information at this time. (Unexpected response)",
              });
            }
          } catch (error) {
            // This catch block handles errors from 'callFirebaseFunction'
            // (e.g., Firebase authentication errors, function execution errors, network errors)
            console.error(`[/streak] Error executing /streak for User ${interaction.user.id}:`, error);
            await interaction.editReply({
              content: `❌ An error occurred while fetching your streak: ${error.message || 'Please try again.'}`,
            });
          }
          break; // Make sure to break after the case
        }

        case 'testai': {
          await interaction.deferReply({ flags: MessageFlags.Ephemeral });

          const result = await testGeminiAPI();

          const message = result.success
            ? `✅ AI Integration Test Successful!\n\nResponse:\n${result.message}`
            : `❌ AI Integration Test Failed:\n${result.error}`;

          return await interaction.editReply({
            content: message,
            flags: MessageFlags.Ephemeral
          });
        }

        case 'leaderboard': {
          // Defer immediately for better UX
          await interaction.deferReply({ flags: MessageFlags.Ephemeral });

          // --- New code using Firebase helper ---
          try {
            // Call the Firebase function using the helper
            // `result` here will be the data returned by the Firebase function
            // (which should include { success: true, message: "...", ... })
            const result = await callFirebaseFunction(
              'getLeaderboard', // Name of the callable function in Firebase
              {},               // No data payload needed for getLeaderboard
              interaction.user.id // Pass the interacting user's ID for authentication
            );

            // Check the success status & message from the Firebase function's return value
            // Our getLeaderboard function returns { success: true, message: '...' }
            if (!result || !result.success || typeof result.message === 'undefined') {
              // If the function failed internally or returned unexpected data
              console.error("Leaderboard function failed or returned unexpected data:", result);
              // Use the error message from Firebase if available, otherwise generic
              throw new Error(result?.message || "Received an unexpected response from the leaderboard service.");
            }

            // Display the message prepared by the Firebase function
            await interaction.editReply({
              content: result.message, // Use the message directly from the Firebase function response
              flags: MessageFlags.Ephemeral
            });

          } catch (error) {
            // Catch errors from callFirebaseFunction (auth errors, function execution errors, network errors)
            console.error(`Error executing /leaderboard for user ${interaction.user.id}:`, error);
            await interaction.editReply({
              // Display the error message thrown by callFirebaseFunction or the catch block above
              content: `❌ Could not retrieve leaderboard. ${error.message || 'Please try again later.'}`,
              flags: MessageFlags.Ephemeral
            });
          }
          // --- End of new code ---
          break; // Ensure break statement is present
        } // End case 'leaderboard'

        // ****** START of REPLACEMENT for 'case exp:' block ******
        case 'go': { // <<< RENAMED from 'exp'
          const goCommandStartTime = performance.now();
          console.log(`[/go] Command received. User: ${interaction.user.tag}, InteractionID: ${interaction.id}. Time: ${goCommandStartTime.toFixed(2)}ms.`);

        try {
          await interaction.deferReply({ flags: MessageFlags.Ephemeral });
          const goDeferSuccessTime = performance.now();
          console.log(`[/go] Deferral took: ${(goDeferSuccessTime - goCommandStartTime).toFixed(2)}ms.`);

          // --- Create an Embed for the Go Hub message ---
          const goHubEmbed = new EmbedBuilder()
            .setColor('#7F00FF') // A nice vibrant purple, change as you like
            .setTitle('🚀 Experiment Control Panel 🚀')
            .setDescription('Welcome to your Go Hub! What would you like to do?')
            .addFields(
                { name: '🔬 Set Experiment', value: 'Define your goals and metrics.', inline: true },
                { name: '✍️ Log Daily Data', value: 'Record daily metrics and notes.', inline: true },
                { name: '📊 Streak Stats', value: 'View your streaks and leaderboard position.', inline: true },
                { name: '💡 AI Insights', value: 'Get AI-powered analysis of your data.', inline: true }
            )

          // --- Build the Go Hub buttons ---
          const setExperimentButton = new ButtonBuilder()
            .setCustomId('set_update_experiment_btn')
            .setLabel('🔬 Set Experiment')
            .setStyle(ButtonStyle.Primary);

          const logProgressButton = new ButtonBuilder()
            .setCustomId('log_daily_progress_btn')
            .setLabel('✍️ Log Daily Data')
            .setStyle(ButtonStyle.Success);

          const streakCenterButton = new ButtonBuilder()
            .setCustomId('streak_center_btn')
            .setLabel('📊 Streak Progress')
            .setStyle(ButtonStyle.Secondary)
            .setDisabled(true); // Disabled for now

          const insightsButton = new ButtonBuilder()
            .setCustomId('ai_insights_btn')
            .setLabel('💡 AI Insights')
            .setStyle(ButtonStyle.Secondary)
            .setDisabled(true); // Disabled until implemented

          const row1 = new ActionRowBuilder().addComponents(setExperimentButton, logProgressButton);
          const row2 = new ActionRowBuilder().addComponents(streakCenterButton, insightsButton);

          await interaction.editReply({
            embeds: [goHubEmbed], // Send the embed
            components: [row1, row2],
          });
          console.log(`[/go] Hub displayed successfully for ${interaction.user.tag}.`);

        } catch (error) {
          console.error(`Error handling /go command for ${interaction.user.tag}: ${error?.code || 'Unknown'}`, error);
          if (interaction.deferred && !interaction.replied) {
            try {
              await interaction.editReply({
                content: '❌ Oops! Something went wrong displaying the Go Hub. Please try the `/go` command again.',
                embeds: [], // Clear embeds on error
                components: []
              });
            } catch (editError) {
              console.error("Error sending fallback editReply for /go:", editError);
            }
          }
        }
        break;
      }

        case 'insights7':
        case 'insights30': {
          console.log("💡 Reached insights command handler");
          await interaction.deferReply({ flags: MessageFlags.Ephemeral });

          const periodDays = interaction.commandName === 'insights7' ? 7 : 30;

          const response = await fetch(SCRIPT_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              action: 'getInsights',
              userId: interaction.user.id,
              userTag: interaction.user.tag,
              periodDays: periodDays
            })
          });

          const responseText = await response.text();
          const result = JSON.parse(responseText);

          if (!result?.data?.priorities) {
            console.error("🧨 Unexpected result structure:", JSON.stringify(result, null, 2));
            await interaction.editReply({
              content: "⚠️ No priorities found in response.",
            });
            return;
          }

          if (!response.ok || !result.success) {
            return await interaction.editReply({
              content: result.message || `❌ ${result.error || 'Failed to generate insights'}`,
              flags: MessageFlags.Ephemeral
            });
          }

          if (result.cached && result.data.aiText) {
            return await interaction.editReply({
              content: `${result.fallback ? '⚠️ Using recent insights while generating new ones.\n\n' : ''}${result.data.aiText}`,
              flags: MessageFlags.Ephemeral
            });
          }

         console.log("📦 Full result from GAS:", JSON.stringify(result));
         console.log("🎯 generateInsights called with:", JSON.stringify(result.data));
      
      const aiResult = await generateInsights(result.data);
      
      if (!aiResult.success) {
        return await interaction.editReply({
          content: `❌ ${aiResult.error || 'Failed to generate AI insights'}`,
        });
      }



          await fetch(SCRIPT_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              action: 'storeInsights',
              userId: interaction.user.id,
              userTag: interaction.user.tag,
              periodDays: periodDays,
              insights: {
                structuredData: result.data,
                aiText: aiResult.insights,
                dataPoints: result.data.userMetrics.dataPoints
              }
            })
          });

          await interaction.user.send(aiResult.insights);

          return await interaction.editReply({
            content: "✨ Check your DMs for insights! 🚀",
            flags: MessageFlags.Ephemeral
          });
        }
        default: {
          console.warn('⚠️ Unrecognized command:', interaction.commandName);
          return await interaction.reply({
            content: '🤔 Unknown command. Please try again or contact support.',
            flags: MessageFlags.Ephemeral
          });
        }
      } // end of switch
        } catch (error) {
      console.error('❌ Error in command handler:', error);

      const timeoutMessage = '🚗 Had to warm up the engine. Please try again now.';
      const genericMessage = '❌ Something went wrong while handling your command.';

      const message = error.name === 'AbortError' ? timeoutMessage : genericMessage;

      if (!interaction.replied && !interaction.deferred) {
        try {
          await interaction.reply({
            content: message,
            flags: MessageFlags.Ephemeral
          });
        } catch (fallbackError) {
          console.error('⚠️ Failed to send fallback error reply:', fallbackError);
        }
      }
    }
  } // end of isChatInputCommand if
  
  // --- Button Interaction Handler ---
  if (interaction.isButton()) {
    // Optional: Add performance logging if desired
    // const buttonStartTime = performance.now();
    // console.log(`⚡ Received button interaction: ${interaction.customId} from ${interaction.user.tag} at ${buttonStartTime.toFixed(2)}ms`);

    // --- Handler for Set Experiment Button ---
    if (interaction.customId === 'set_update_experiment_btn') {
      try {
        const modal = new ModalBuilder()
          .setCustomId('experiment_setup_modal') // Unique ID for this modal submission
          .setTitle('🧪 Set Weekly Experiment');

        // Define Modal Components (Text Inputs)

        const deeperProblemInput = new TextInputBuilder()
          .setCustomId('deeper_problem')
          .setLabel("🎯 What deeper problem are you working on?")
          .setPlaceholder("e.g., Low energy. I want to go to sleep earlier.")
          .setStyle(TextInputStyle.Paragraph) // Paragraph for longer input
          .setRequired(true);

        const outputSettingInput = new TextInputBuilder()
          .setCustomId('output_setting')
          .setLabel("📈 Output (Format: Goal #, Unit, Activity)") // Ensure commas are clear
          .setPlaceholder("e.g.: 10, pm, Bedtime") // Comma format example
          .setStyle(TextInputStyle.Short)
          .setRequired(true);

        const input1SettingInput = new TextInputBuilder()
          .setCustomId('input1_setting')
          .setLabel("🧪 Input 1 (Format: Goal #, Unit, Activity)") // Comma format example
          .setPlaceholder("e.g.: 15, minutes, Meditation")
          .setStyle(TextInputStyle.Short)
          .setRequired(true);

        const input2SettingInput = new TextInputBuilder()
          .setCustomId('input2_setting')
          .setLabel("🧪 Input 2 (Same format - Optional)")
          .setPlaceholder("e.g.: 5000, steps, Walking")
          .setStyle(TextInputStyle.Short)
          .setRequired(false); // Optional

        const input3SettingInput = new TextInputBuilder()
          .setCustomId('input3_setting')
          .setLabel("🧪 Input 3 (Same format - Optional)") // Comma format example
          .setPlaceholder("e.g., 10, glasses, Water")
          .setStyle(TextInputStyle.Short)
          .setRequired(false); // Optional

        // Add components to modal using ActionRows (one per component for modals)
        const firstRow = new ActionRowBuilder().addComponents(deeperProblemInput);
        const secondRow = new ActionRowBuilder().addComponents(outputSettingInput);
        const thirdRow = new ActionRowBuilder().addComponents(input1SettingInput);
        const fourthRow = new ActionRowBuilder().addComponents(input2SettingInput);
        const fifthRow = new ActionRowBuilder().addComponents(input3SettingInput);

        modal.addComponents(firstRow, secondRow, thirdRow, fourthRow, fifthRow);

        // Show the modal to the user
        await interaction.showModal(modal);
        // Optional: Log success
        // console.log(`[${interaction.customId}] Modal shown successfully.`);

      } catch (error) {
        console.error(`[${interaction.customId}] Error showing modal:`, error);
        // We generally cannot reply to the button interaction if showModal fails,
        // especially if it's an "Unknown Interaction" type error.
        // Logging is the primary action here.
      }
    }

    // ****** START: Add these NEW Button Handlers inside the 'if (interaction.isButton())' block ******

    // --- Handler for Log Daily Data Button ---
    else if (interaction.customId === 'log_daily_progress_btn') {
      const logButtonStartTime = performance.now();
      console.log(`[log_daily_progress_btn] Button clicked by User: ${interaction.user.tag}, InteractionID: ${interaction.id}`);
      try {
          // Logic copied from the old /log command handler

          const fetchSettingsStartTime = performance.now();
          console.log(`[log_daily_progress_btn] Fetching weekly settings for User: ${interaction.user.id}`);
          const settingsResult = await callFirebaseFunction('getWeeklySettings', {}, interaction.user.id);
          const fetchSettingsTime = performance.now();
          console.log(`[log_daily_progress_btn] getWeeklySettings call took: ${(fetchSettingsTime - fetchSettingsStartTime).toFixed(2)}ms.`);

          if ((fetchSettingsTime - logButtonStartTime) > 2800) {
              console.warn(`[log_daily_progress_btn] Fetching settings took >2.8s for User ${interaction.user.tag}. Interaction likely expired.`);
              try {
                   await interaction.followUp({ content: "🚦 Sorry, we tripped while getting your settings. Please click 'Log Daily Data' again.", flags: MessageFlags.Ephemeral });
              } catch (followUpError) {
                 console.error('[log_daily_progress_btn] Failed to send timeout follow-up message:', followUpError);
              }
              return;
          }

          if (!settingsResult || !settingsResult.settings) {
            await interaction.update({
              content: "🤔 You haven't set up your weekly experiment yet. Please use the 'Set Experiment' button first from the `/go` hub.",
              embeds: [], // Clear any previous embed
              components: []
            });
            return;
          }
          const settings = settingsResult.settings;
          const outputConfigured = settings.output && settings.output.label && settings.output.label.trim() !== "";
          const input1Configured = settings.input1 && settings.input1.label && settings.input1.label.trim() !== "";
          if (!outputConfigured || !input1Configured) {
            await interaction.update({
              content: "📝 Your experiment setup is incomplete (Output & Input 1 required). Please use 'Set Experiment' from the `/go` hub to set them.",
              embeds: [], // Clear any previous embed
              components: []
            });
            return;
          }

          console.log(`[log_daily_progress_btn] Building modal for user ${interaction.user.id}.`);
          const modal = new ModalBuilder()
            .setCustomId('dailyLogModal_firebase')
            .setTitle(`📝 Fuel Your Experiment With Data`);
          const components = [];

          components.push(
            new ActionRowBuilder().addComponents(
              new TextInputBuilder()
                .setCustomId('log_output_value')
                .setLabel(`${settings.output.label} ${settings.output.unit}`)
                .setPlaceholder(`e.g., ${settings.output.goal}`)
                .setStyle(TextInputStyle.Short)
                .setRequired(true)
            )
          );
          components.push(
            new ActionRowBuilder().addComponents(
              new TextInputBuilder()
                .setCustomId('log_input1_value')
                .setLabel(`${settings.input1.label} ${settings.input1.unit}`)
                .setPlaceholder(`e.g. ${settings.input1.goal}`)
                .setStyle(TextInputStyle.Short)
                .setRequired(true)
            )
          );
          if (settings.input2 && settings.input2.label && settings.input2.label.trim() !== "") {
            components.push(
              new ActionRowBuilder().addComponents(
                new TextInputBuilder()
                  .setCustomId('log_input2_value')
                  .setLabel(`${settings.input2.label} ${settings.input2.unit}`)
                  .setPlaceholder(`e.g. ${settings.input2.goal}`)
                  .setStyle(TextInputStyle.Short)
                  .setRequired(true)
              )
             );
          }
          if (settings.input3 && settings.input3.label && settings.input3.label.trim() !== "") {
            components.push(
              new ActionRowBuilder().addComponents(
                new TextInputBuilder()
                  .setCustomId('log_input3_value')
                  .setLabel(`${settings.input3.label} ${settings.input3.unit}`)
                  .setPlaceholder(`e.g., ${settings.input3.goal}`)
                  .setStyle(TextInputStyle.Short)
                  .setRequired(true)
               )
            );
          }
          components.push(
            new ActionRowBuilder().addComponents(
              new TextInputBuilder()
                .setCustomId('log_notes')
                .setLabel('💭 Experiment (and life) Notes')
                .setPlaceholder(
                  settings.deeperProblem
                    ? `Focus: ${settings.deeperProblem.substring(0, 85)}${settings.deeperProblem.length > 85 ? '...' : ''}`
                    : 'What did you observe? Any questions or insights?'
                )
                .setStyle(TextInputStyle.Paragraph)
                .setRequired(true)
             )
          );

          modal.addComponents(components.slice(0, 5));
          await interaction.showModal(modal);
          const showModalTime = performance.now();
          console.log(`[log_daily_progress_btn] showModal called successfully at ${showModalTime.toFixed(2)}ms. Total time: ${(showModalTime - logButtonStartTime).toFixed(2)}ms`);

      } catch (error) {
          console.error(`[log_daily_progress_btn] Error for User ${interaction.user.tag}, InteractionID: ${interaction.id}:`, error);
           if (!interaction.replied && !interaction.deferred && !interaction.responded) {
                let userErrorMessage = '❌ An error occurred while preparing your log form. Please try again.';
                if (error.message && (error.message.includes('Firebase Error') || error.message.includes('authentication failed'))) {
                      userErrorMessage = `❌ Error fetching settings: ${error.message}`;
                }
                try {
                    await interaction.reply({ content: userErrorMessage, flags: MessageFlags.Ephemeral });
                } catch (replyError) { console.error('[log_daily_progress_btn] Failed to send error reply:', replyError); }
           } else {
                try {
                     await interaction.followUp({ content: '❌ An error occurred after initiating the log process. Please try clicking the button again.', flags: MessageFlags.Ephemeral });
                 } catch (followUpError) { console.error('[log_daily_progress_btn] Failed to send error follow-up:', followUpError); }
           }
      }
    }

    // --- Placeholder Handler for Streak Progress Button ---
    else if (interaction.customId === 'streak_center_btn') {
        try {
            // This button is disabled, but if it were enabled, an ephemeral update is good.
            await interaction.update({ // Using update to acknowledge the button click, ephemerally
                content: "📊 Streak Progress coming soon! This message will self-destruct (not really, but it's just for you).",
                embeds: [], // Clear embeds
                components: [], // Remove buttons after click
                flags: MessageFlags.Ephemeral
            });
        } catch (error) {
            console.error(`Error replying to disabled button ${interaction.customId}:`, error);
             // If update failed, try a followup
            try {
                await interaction.followUp({ content: "📊 Streak Progress coming soon!", flags: MessageFlags.Ephemeral });
            } catch (followUpError) {
                console.error(`Error sending followup for ${interaction.customId}:`, followUpError);
            }
        }
    }

    // --- Placeholder Handler for AI Insights Button ---
    else if (interaction.customId === 'ai_insights_btn') {
        try {
            await interaction.update({
                content: "💡 AI Insights feature coming soon! Stay tuned.",
                embeds: [],
                components: [],
                flags: MessageFlags.Ephemeral
            });
        } catch (error) {
            console.error(`Error replying to disabled button ${interaction.customId}:`, error);
            try {
                await interaction.followUp({ content: "💡 AI Insights feature coming soon!", flags: MessageFlags.Ephemeral });
            } catch (followUpError) {
                console.error(`Error sending followup for ${interaction.customId}:`, followUpError);
            }
        }
    }

// ****** END: Add these NEW Button Handlers inside the 'if (interaction.isButton())' block ******

  } // End of "if (interaction.isButton())" block


   // Handle modal submission

 // +++ COMPLETE MODAL SUBMISSION HANDLER FOR DAILY LOG (FIREBASE) +++
if (interaction.isModalSubmit() && interaction.customId === 'dailyLogModal_firebase') {

  const modalSubmitStartTime = performance.now();
  console.log(`[dailyLogModal_firebase] Submission received by User: ${interaction.user.tag}, InteractionID: ${interaction.id}`);
  let userData = null; // To store fetched user data for final message/actions
  let actionErrors = []; // Keep track of errors during actions

  try {
    // 1. Defer Reply
    await interaction.deferReply({ flags: MessageFlags.Ephemeral });
    const deferTime = performance.now();
    console.log(`[dailyLogModal_firebase] Deferral took: ${(deferTime - modalSubmitStartTime).toFixed(2)}ms`);

    // 2. Extract Submitted Values
    const outputValue = interaction.fields.getTextInputValue('log_output_value')?.trim();
    const input1Value = interaction.fields.getTextInputValue('log_input1_value')?.trim();
    let input2Value = "";
    try { input2Value = interaction.fields.getTextInputValue('log_input2_value')?.trim(); } catch { /* Field likely didn't exist */ }
    let input3Value = "";
    try { input3Value = interaction.fields.getTextInputValue('log_input3_value')?.trim(); } catch { /* Field likely didn't exist */ }
    const notes = interaction.fields.getTextInputValue('log_notes')?.trim();

    // 3. Basic Validation (Client-side check)
    if (!outputValue || !input1Value || !notes) {
        await interaction.editReply({ content: "❌ Missing required fields (Output, Input 1, or Notes)." });
        return;
    }
    // Add specific validation for numeric inputs if desired, though Firebase function also validates
    if (isNaN(parseFloat(outputValue))) {
        await interaction.editReply({ content: `❌ Value for Output must be a number. You entered: "${outputValue}"` });
        return;
    }
    if (isNaN(parseFloat(input1Value))) {
        await interaction.editReply({ content: `❌ Value for Input 1 must be a number. You entered: "${input1Value}"` });
        return;
    }
    if (input2Value && isNaN(parseFloat(input2Value))) {
        await interaction.editReply({ content: `❌ Value for Input 2 must be a number if provided. You entered: "${input2Value}"` });
        return;
    }
    if (input3Value && isNaN(parseFloat(input3Value))) {
        await interaction.editReply({ content: `❌ Value for Input 3 must be a number if provided. You entered: "${input3Value}"` });
        return;
    }


    // 4. Structure Payload for Firebase 'submitLog' (HTTP) Function
    const payload = { outputValue, inputValues: [input1Value, input2Value || "", input3Value || ""], notes };
    console.log('[dailyLogModal_firebase] Payload for submitLog (HTTP):', payload);

    const fbCallStartTime = performance.now();
    console.log(`[dailyLogModal_firebase] Calling submitLog (HTTP) for User: ${interaction.user.id}...`);

    let submitResult;
    let httpResponseOk = false;
    try {
        await authenticateFirebaseUser(interaction.user.id);
        const currentUser = firebaseAuth.currentUser;
        if (!currentUser) {
            throw new Error("Bot client could not get current Firebase user after auth. Cannot get ID token.");
        }
        const idToken = await getIdToken(currentUser);
        const submitLogHttpUrl = "https://us-central1-self-science-bot.cloudfunctions.net/submitLog"; // Ensure this is your correct URL

        const apiResponse = await fetch(submitLogHttpUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${idToken}`
            },
            body: JSON.stringify(payload)
        });
        httpResponseOk = apiResponse.ok;
        submitResult = await apiResponse.json();
    } catch (fetchError) {
        console.error('[dailyLogModal_firebase] Fetch error calling submitLog (HTTP):', fetchError);
        submitResult = { success: false, error: `Network or parsing error calling log service: ${fetchError.message}`, code: 'fetch-error' };
        httpResponseOk = false;
    }

    const fbCallEndTime = performance.now();
    console.log(`[dailyLogModal_firebase] submitLog (HTTP) call took: ${(fbCallEndTime - fbCallStartTime).toFixed(2)}ms. Ok: ${httpResponseOk}, Result:`, submitResult);

    if (!httpResponseOk || !submitResult || submitResult.success !== true) {
        const errorMessage = submitResult?.error || (httpResponseOk ? 'Log service returned failure.' : `Failed to reach log service (Status: ${submitResult?.status || 'N/A'}).`); // submitResult might not have status
        const errorCode = submitResult?.code || (httpResponseOk ? 'service-failure' : 'network-failure');
        console.error(`[dailyLogModal_firebase] submitLog (HTTP) indicated failure. Code: ${errorCode}, Message: ${errorMessage}`, submitResult);
        await interaction.editReply({ content: `❌ Error saving log: ${errorMessage}` });
        return;
    }

    // Log successfully saved, now fetch updated user data
    console.log(`[dailyLogModal_firebase] Log ${submitResult.logId} saved. Fetching user data for bot...`);

    // >>>>> START: TEMPORARY DELAY FOR TESTING PUBLIC MESSAGE TIMING <<<<<
    console.log('[dailyLogModal_firebase] Introducing TEMPORARY 3-second delay before fetching user data...');
    await new Promise(resolve => setTimeout(resolve, 3000)); // Wait for 3 seconds
    console.log('[dailyLogModal_firebase] TEMPORARY delay finished.');
    // >>>>> END: TEMPORARY DELAY FOR TESTING PUBLIC MESSAGE TIMING <<<<<

    const fetchUserDataStartTime = performance.now();
    const userDataResult = await callFirebaseFunction('getUserDataForBot', {}, interaction.user.id);
    const fetchUserDataEndTime = performance.now();
    console.log(`[dailyLogModal_firebase] getUserDataForBot call took: ${(fetchUserDataEndTime - fetchUserDataStartTime).toFixed(2)}ms.`);

    if (!userDataResult || userDataResult.success !== true || !userDataResult.userData) {
       console.error('[dailyLogModal_firebase] Failed to fetch user data after log submission:', userDataResult);
       await interaction.editReply({ content: `✅ Log saved (ID: ${submitResult.logId})! However, there was an issue fetching updated streak/role info. It should update shortly.` });
       return;
    }
    userData = userDataResult.userData;
    console.log('[dailyLogModal_firebase] Fetched User Data:', JSON.stringify(userData, null, 2));

    const guild = interaction.guild;
    const member = interaction.member || await guild?.members.fetch(interaction.user.id).catch(err => {
         console.error(`[dailyLogModal_firebase] Failed to fetch member ${interaction.user.id}:`, err);
         return null;
    });

    // --- Process Pending Actions ---
    // This section is where all pending actions (DMs, Roles, Public Messages) are handled.

    // 7a. Pending DM Message
    if (userData.pendingDmMessage && typeof userData.pendingDmMessage === 'string' && userData.pendingDmMessage.trim() !== "") {
      console.log(`[dailyLogModal_firebase] Sending pending DM to ${interaction.user.tag}: "${userData.pendingDmMessage}"`);
      try {
        await interaction.user.send(userData.pendingDmMessage);
      } catch (dmError) {
        console.error(`[dailyLogModal_firebase] Failed to send pending DM to ${interaction.user.tag}:`, dmError);
        actionErrors.push("Failed to send DM with streak/milestone updates.");
        if (dmError.code === 50007) {
           actionErrors.push("Note: I couldn't DM you. Please check server privacy settings if you want DMs.");
        }
      }
    }

    // Only proceed with role/public channel messages if guild and member objects are available
    if (guild && member) {
        // 7b. Pending Freeze Role Update
        if (userData.pendingFreezeRoleUpdate && typeof userData.pendingFreezeRoleUpdate === 'string' && userData.pendingFreezeRoleUpdate.trim() !== "") {
           const targetFreezeRoleName = userData.pendingFreezeRoleUpdate;
           console.log(`[dailyLogModal_firebase] Processing freeze role update for ${member.user.tag} to: ${targetFreezeRoleName}`);
           try {
               const targetRole = await ensureRole(guild, targetFreezeRoleName, '#ADD8E6'); // Light blue
               const currentFreezeRoles = member.roles.cache.filter(role => role.name.startsWith(FREEZE_ROLE_BASENAME) && role.name !== targetFreezeRoleName);
               if (currentFreezeRoles.size > 0) {
                   await member.roles.remove(currentFreezeRoles);
                   console.log(`[dailyLogModal_firebase] Removed ${currentFreezeRoles.size} old freeze roles from ${member.user.tag}.`);
               }
               if (!member.roles.cache.has(targetRole.id)) {
                   await member.roles.add(targetRole);
                   console.log(`[dailyLogModal_firebase] Added freeze role "${targetFreezeRoleName}" to ${member.user.tag}.`);
               }
           } catch (freezeRoleError) {
               console.error(`[dailyLogModal_firebase] Error updating freeze role for ${member.user.tag}:`, freezeRoleError);
               actionErrors.push(`Failed to update freeze role to ${targetFreezeRoleName}.`);
           }
        }

        // 7c. Pending Role Cleanup / Regular Role Update
        if (userData.pendingRoleCleanup === true || (userData.pendingRoleUpdate && userData.pendingRoleUpdate.name)) {
            console.log(`[dailyLogModal_firebase] Processing role cleanup/update for ${member.user.tag}. Cleanup: ${userData.pendingRoleCleanup}, NewRole: ${userData.pendingRoleUpdate ? userData.pendingRoleUpdate.name : 'None'}`);
            try {
                let rolesToRemove = [];
                if (userData.pendingRoleCleanup === true) {
                    member.roles.cache.forEach(role => {
                        if (STREAK_MILESTONE_ROLE_NAMES.includes(role.name) && role.name !== 'Originator') { // Do not remove Originator during cleanup
                            rolesToRemove.push(role);
                        }
                    });
                    if (rolesToRemove.length > 0) {
                       console.log(`[dailyLogModal_firebase] Identified roles to remove for cleanup:`, rolesToRemove.map(r => r.name));
                       await member.roles.remove(rolesToRemove);
                       console.log(`[dailyLogModal_firebase] Performed role cleanup for ${member.user.tag}.`);
                    }
                }

                if (userData.pendingRoleUpdate && userData.pendingRoleUpdate.name) {
                    const newRoleInfo = userData.pendingRoleUpdate; // { name, color, days }
                    console.log(`[dailyLogModal_firebase] Assigning new role: ${newRoleInfo.name}`);
                    const newRole = await ensureRole(guild, newRoleInfo.name, newRoleInfo.color);
                    if (!member.roles.cache.has(newRole.id)) {
                       await member.roles.add(newRole);
                       console.log(`[dailyLogModal_firebase] Added role "${newRole.name}" to ${member.user.tag}.`);
                    }
                }
            } catch (roleError) {
                console.error(`[dailyLogModal_firebase] Error during role cleanup/update for ${member.user.tag}:`, roleError);
                actionErrors.push("Failed to update your streak role.");
            }
        }

        // This replaces any old, direct channel.send messages for milestones/extensions.
        if (userData.pendingPublicMessage && typeof userData.pendingPublicMessage === 'string' && userData.pendingPublicMessage.trim() !== "") {
            console.log(`[dailyLogModal_firebase] Attempting to send public message to channel ${interaction.channelId}: "${userData.pendingPublicMessage}"`);
            try {
                // Send to the channel where the /log command was initiated
                await interaction.channel.send(userData.pendingPublicMessage);
                console.log(`[dailyLogModal_firebase] Successfully sent public message for user ${interaction.user.tag}.`);
            } catch (publicMsgError) {
                console.error(`[dailyLogModal_firebase] Failed to send pending public message for user ${interaction.user.tag}:`, publicMsgError);
                actionErrors.push("Failed to post public announcement to the channel.");
            }
        } else if (userData.pendingPublicMessage) {
            // Log if we have a message but it's not a sendable string (e.g. null, empty after trim)
             console.log(`[dailyLogModal_firebase] Had a pendingPublicMessage but it was not a valid string to send. Content: "${userData.pendingPublicMessage}"`);
        }

    } else { // End of if (guild && member)
        console.warn(`[dailyLogModal_firebase] Guild or Member object not available for user ${interaction.user.id}. Skipping public messages and role updates.`);
        if (userData.pendingPublicMessage || userData.pendingFreezeRoleUpdate || userData.pendingRoleCleanup || userData.pendingRoleUpdate) {
            actionErrors.push("Could not perform role updates or public announcements (guild/member data unavailable).");
        }
    }

    // 8. Clear Pending Actions in Firebase (CRITICAL: Call this LAST)
    console.log(`[dailyLogModal_firebase] Calling clearPendingUserActions for ${interaction.user.id}...`);
    try {
       await callFirebaseFunction('clearPendingUserActions', {}, interaction.user.id);
       console.log(`[dailyLogModal_firebase] Successfully cleared pending actions for ${interaction.user.id}.`);
    } catch (clearError) {
       console.error(`[dailyLogModal_firebase] FAILED to clear pending actions for ${interaction.user.id}:`, clearError);
       actionErrors.push("Critical: Failed to clear pending server actions (may retry on next log).");
    }

    // 9. Construct Final Ephemeral Confirmation Message
    const randomMessage = inspirationalMessages[Math.floor(Math.random() * inspirationalMessages.length)];
    // Include streak info in the ephemeral confirmation for immediate feedback
    let finalMessage = `✅ Log saved!\n\n${randomMessage}\n\n🔥 Current Streak: ${userData.currentStreak || 0} days\n🧊 Freezes: ${userData.freezesRemaining || 0}`;

    if (actionErrors.length > 0) {
      finalMessage += `\n\n⚠️ **Note:**\n- ${actionErrors.join('\n- ')}`;
    }

    // 10. Edit the Original Deferred Reply with the final ephemeral message
    await interaction.editReply({ content: finalMessage });

    // 11. Send Non-Ephemeral DM with Log Summary (as before)
    let logSummarySettings = null;
    try {
        const settingsResultForDM = await callFirebaseFunction('getWeeklySettings', {}, interaction.user.id);
        if (settingsResultForDM && settingsResultForDM.settings) {
            logSummarySettings = settingsResultForDM.settings;
        }
    } catch (settingsError) {
        console.error('[dailyLogModal_firebase] Error fetching settings for DM summary:', settingsError);
    }
    
    const now = new Date();
    const unixTimestamp = Math.floor(now.getTime() / 1000);
    let dmContent = `**📝 Your Log Summary** (<t:${unixTimestamp}:F>)\n\n`;
    if (logSummarySettings && typeof logSummarySettings === 'object') {
        if (logSummarySettings.deeperProblem) {
            dmContent += `🎯 **Deeper Problem:** ${logSummarySettings.deeperProblem}\n\n`;
        }
        const outputLabel = logSummarySettings.output?.label || 'Output';
        const outputUnit = logSummarySettings.output?.unit || '';
        dmContent += `📊 **${outputLabel}**: ${payload.outputValue} ${outputUnit}\n`.trimEnd() + '\n';
        
        const inputSettingsArray = [logSummarySettings.input1, logSummarySettings.input2, logSummarySettings.input3];
        for (let i = 0; i < payload.inputValues.length; i++) {
            const currentInputSetting = inputSettingsArray[i];
            const inputValue = payload.inputValues[i];
            if ((currentInputSetting && currentInputSetting.label && currentInputSetting.label.trim() !== "") || (inputValue && inputValue.trim() !== "")) {
                const label = currentInputSetting?.label || `Input ${i + 1}`;
                const unit = currentInputSetting?.unit || '';
                dmContent += `🧪 **${label}**: ${inputValue || "*Not logged*"} ${unit}`.trimEnd() + '\n';
            }
        }
    } else {
        dmContent += `Output: ${payload.outputValue || '*Not logged*'}\n`;
        dmContent += `Input 1: ${payload.inputValues[0] || '*Not logged*'}\n`;
        if (payload.inputValues[1]) dmContent += `Input 2: ${payload.inputValues[1]}\n`;
        if (payload.inputValues[2]) dmContent += `Input 3: ${payload.inputValues[2]}\n`;
    }
    dmContent += `\n💭 **Notes:**\n${payload.notes || '*No notes*'}`;
    try {
        await interaction.user.send({ content: dmContent });
        console.log(`[dailyLogModal_firebase] Sent log summary DM to ${interaction.user.tag}`);
    } catch (dmError) {
        console.error(`[dailyLogModal_firebase] Failed to send log summary DM to ${interaction.user.tag}:`, dmError);
        if (interaction.channel && dmError.code === 50007) {
            try {
                await interaction.followUp({ content: "I tried to DM you a copy of your log, but your DMs are closed for this server or with me.", flags: MessageFlags.Ephemeral });
            } catch (followUpError) {
                console.error('[dailyLogModal_firebase] Failed to send DM failure follow-up:', followUpError);
            }
        }
    }

  } catch (error) { // Catch for the main try block
    const errorTime = performance.now();
    console.error(`[dailyLogModal_firebase] MAIN CATCH BLOCK ERROR for User ${interaction.user.tag} at ${errorTime.toFixed(2)}ms:`, error);
    let userErrorMessage = '❌ An unexpected error occurred while saving or processing your log. Please try again.';
    if (error.message) {
       if (error.message.includes('Firebase Error') || error.message.includes('authentication failed') || error.message.includes('connection not ready')) {
          userErrorMessage = `❌ ${error.message}`;
       } else if (error.message.includes('Please set your weekly goals')) { // This might be from an old error path, Firebase function handles it now
           userErrorMessage = `❌ ${error.message} Use /exp first.`;
       }
    }
    if (interaction.deferred || interaction.replied) { // Check if deferred or already replied (e.g. initial defer was successful)
      try {
        await interaction.editReply({ content: userErrorMessage });
      } catch (editError) { console.error('[dailyLogModal_firebase] Failed to send main error via editReply:', editError); }
    } else { // If not even deferred (e.g. defer failed)
       try { await interaction.reply({ content: userErrorMessage, flags: MessageFlags.Ephemeral }); }
       catch (replyError) { console.error('[dailyLogModal_firebase] Failed to send main error via reply:', replyError); }
    }
  } // End main try-catch block

  const modalProcessEndTime = performance.now();
  console.log(`[experiment_setup_modal END ${interactionId}] Processing finished for User: ${interaction.user.tag}. Total time: ${(modalProcessEndTime - modalSubmitStartTime).toFixed(2)}ms`);
 }
// --- END OF COMPLETE DAILY LOG MODAL SUBMISSION HANDLER ---

// Handle test modal submission
if (interaction.isModalSubmit() && interaction.customId === 'testLogPreview') {
  try {
    // Use same priority parsing function
    function parsePriority(input) {
      const regex = /^(.*?)[,\.\-_:]+\s*(\d+)\s*(.*)$/;
      const match = input.trim().match(regex);
      if (!match) return null;
      let [_, label, value, unit] = match;
      label = label.trim().substring(0, 500);
      value = value.trim();
      unit = unit.trim();
      if (!unit) unit = 'effort';
      return { label, value, unit };
    }

    // Validate priorities
    const priorities = [];
    for (let i = 1; i <= 3; i++) {
      const input = interaction.fields.getTextInputValue(`priority${i}`);
      const parsed = parsePriority(input);
      if (!parsed || !parsed.label || !parsed.value) {
        return await interaction.reply({
          content: `❌ Invalid format for Priority ${i}. Use: "Activity, value units" or "Rating, number/10 effort"`,
          flags: ['Ephemeral']
        });
      }
      priorities.push(parsed);
    }

    // Validate satisfaction
    const satisfactionRaw = interaction.fields.getTextInputValue('satisfaction');
    const satisfaction = parseInt(satisfactionRaw, 10);
    if (isNaN(satisfaction) || satisfaction < 0 || satisfaction > 10) {
      return await interaction.reply({
        content: "❌ Satisfaction must be a number between 0 and 10.",
        flags: ['Ephemeral']
      });
    }

    // Validate notes
    const notes = interaction.fields.getTextInputValue('notes');
    if (!notes || !notes.trim()) {
      return await interaction.reply({
        content: "❌ Notes field is required.",
        flags: ['Ephemeral']
      });
    }
    
    // If all validation passes, show preview
    await interaction.reply({
      content: `✅ Your log would look like this:

    Priority 1: ${priorities[0].label}, ${priorities[0].value} ${priorities[0].unit}
    Priority 2: ${priorities[1].label}, ${priorities[1].value} ${priorities[1].unit}
    Priority 3: ${priorities[2].label}, ${priorities[2].value} ${priorities[2].unit}
    Satisfaction: ${satisfaction}/10
    Notes: ${notes}

    Ready to log for real? Use /log to begin your streak!`,
      flags: ['Ephemeral']
    });
  } catch (error) {
    console.error('Error in test modal submission:', error);
    await interaction.reply({
      content: '❌ There was an error processing your test log. Please try again.',
      flags: ['Ephemeral']
    });
  }
  return;
 }

// Modal submission handler
if (interaction.isModalSubmit() && interaction.customId === 'weeklyPriorities') {
  try {
    await interaction.deferReply({ flags: MessageFlags.Ephemeral });

    // Get and validate priorities
    const priorities = [];
    for (let i = 1; i <= 3; i++) {
      const input = interaction.fields.getTextInputValue(`priority${i}`).trim();
      
      // Check comma format
      if (!input.includes(',')) {
        await interaction.editReply({
          content: `❌ Priority ${i} must include a comma to separate the label and unit.\nExample: "Meditation, minutes"`,
          flags: MessageFlags.Ephemeral
        });
        return;
      }

      // Split and trim
      const [label, unit] = input.split(',').map(part => part.trim());
      
      if (!label || !unit) {
        await interaction.editReply({
          content: `❌ Priority ${i} must have both a label and unit.\nExample: "Meditation, minutes"`,
          flags: MessageFlags.Ephemeral
        });
        return;
      }

      priorities.push(input);
    }

    // Send to Google Apps Script
    const response = await fetch(SCRIPT_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        action: 'updateWeeklyPriorities',
        userId: interaction.user.id,
        userTag: interaction.user.tag,
        priorities: priorities
      })
    });

    const result = await response.json();
    if (!result.success) {
  console.error("❌ Script returned error:", result.error);
  await interaction.editReply({
    content: "❌ Script error: " + (result.error || "Unknown error"),
    flags: MessageFlags.Ephemeral
  });
  return;
  }

    if (result.success) {
      // Show confirmation
      const confirmationMessage = [
        '✅ Weekly priorities set!',
        '',
        'Your priorities:',
        ...priorities.map((p, i) => `${i + 1}. **${p}**`)
      ].join('\n');

      await interaction.editReply({
        content: confirmationMessage,
        flags: MessageFlags.Ephemeral
      });
    } else {
      await interaction.editReply({
        content: `❌ ${result.error || 'Failed to set priorities. Please try again.'}`,
        flags: MessageFlags.Ephemeral
      });
    }

  } catch (error) {
    console.error('Error in weekly priorities submission:', error);
    await interaction.editReply({
      content: '❌ An error occurred while saving your priorities. Please try again.',
      flags: MessageFlags.Ephemeral
    });
  }
 }

 // +++ NEW MODAL SUBMISSION HANDLER FOR EXPERIMENT SETUP +++
 // --- START: REPLACE THIS SECTION in render index testing1.txt (The 'experiment_setup_modal' handler) ---
 if (interaction.isModalSubmit() && interaction.customId === 'experiment_setup_modal') {
  const modalSubmitStartTime = performance.now();
  const interactionId = interaction.id; // Keep using interactionId for logs
  console.log(`[experiment_setup_modal START ${interactionId}] Received by User: ${interaction.user.tag}`);
  try {
      // --- ACTION 1: Add deferReply ---
      await interaction.deferReply({ flags: MessageFlags.Ephemeral });
      const deferTime = performance.now();
      console.log(`[experiment_setup_modal DEFERRED ${interactionId}] Reply deferred. Took: ${(deferTime - modalSubmitStartTime).toFixed(2)}ms`);
      // --- End Action 1 ---

      const deeperProblem = interaction.fields.getTextInputValue('deeper_problem')?.trim();
      const outputSettingStr = interaction.fields.getTextInputValue('output_setting')?.trim();
      const input1SettingStr = interaction.fields.getTextInputValue('input1_setting')?.trim();
      const input2SettingStr = interaction.fields.getTextInputValue('input2_setting')?.trim();
      const input3SettingStr = interaction.fields.getTextInputValue('input3_setting')?.trim();
      const getLabel = (settingStr, defaultLabel) => { if (!settingStr) return defaultLabel; const parts = settingStr.split(','); return parts.length > 2 ? parts[2].trim() : defaultLabel; };
      console.log(`[experiment_setup_modal DATA ${interactionId}] Extracted values:`, { deeperProblem, outputSettingStr, input1SettingStr, input2SettingStr, input3SettingStr });

      const payload = { deeperProblem, outputSetting: outputSettingStr, inputSettings: [input1SettingStr, input2SettingStr || "", input3SettingStr || ""] };

      const fbCallStartTime = performance.now();
      console.log(`[experiment_setup_modal FIREBASE_CALL ${interactionId}] Calling updateWeeklySettings...`);
      const result = await callFirebaseFunction('updateWeeklySettings', payload, interaction.user.id);
      const fbCallEndTime = performance.now();
      console.log(`[experiment_setup_modal FIREBASE_RETURN ${interactionId}] updateWeeklySettings call took: ${(fbCallEndTime - fbCallStartTime).toFixed(2)}ms.`);

      if (result && result.success === true && typeof result.message === 'string') {
           // Store data needed for subsequent steps (like reminder setup)
        userExperimentSetupData.set(interaction.user.id, {
          settingsMessage: result.message,
          deeperProblem: payload.deeperProblem, // Use payload from earlier in this handler
          input1Label: getLabel(payload.inputSettings[0], "Input 1"),
          input2Label: getLabel(payload.inputSettings[1], null),
          input3Label: getLabel(payload.inputSettings[2], null),
          outputLabel: getLabel(payload.outputSetting, "Output"),
          rawPayload: payload
      });

      // --- Build the Duration Embed (Using User Preferences from previous step) ---
      const durationEmbed = new EmbedBuilder()
          .setColor('#47d264') // Your Color
          .setTitle('Experiment Duration') // Your Title
          .setDescription('When do you want your stats delivered?') // Your Description
          .setFooter({ text: 'Your choice determines the stats reporting interval.' })
          .setTimestamp();

      // --- Build the Duration Select Menu ---
      const durationSelect = new StringSelectMenuBuilder()
          .setCustomId('experiment_duration_select') // This ID triggers the handler added in the previous step
          .setPlaceholder('See your stats in...') // Your Placeholder
          .addOptions(
              new StringSelectMenuOptionBuilder().setLabel('1 Week').setValue('1_week').setDescription('Report in 7 days.'),
              new StringSelectMenuOptionBuilder().setLabel('2 Weeks').setValue('2_weeks').setDescription('Report in 14 days.'),
              new StringSelectMenuOptionBuilder().setLabel('3 Weeks').setValue('3_weeks').setDescription('Report in 21 days.'),
              new StringSelectMenuOptionBuilder().setLabel('4 Weeks').setValue('4_weeks').setDescription('Report in 28 days.')
          );

      const durationRow = new ActionRowBuilder().addComponents(durationSelect);

      console.log(`[experiment_setup_modal EDIT_REPLY ${interactionId}] Attempting editReply with duration embed/select...`);
      // --- Edit the Reply Directly with Duration Selection ---
      await interaction.editReply({
          content: '', // Clear the "settings saved" text
          embeds: [durationEmbed],
          components: [durationRow]
          // Ephemeral status is inherited
      });
      console.log(`[experiment_setup_modal EDIT_REPLY_SUCCESS ${interactionId}] Edited reply with duration selection.`);
      }

   } catch (error) {
      const errorTime = performance.now();
      console.error(`[experiment_setup_modal CRITICAL_ERROR ${interactionId}] Error at ${errorTime.toFixed(2)}ms:`, error);
      let userErrorMessage = '❌ An unexpected error occurred. Please try again.';
      if (error.message?.includes('Firebase Error') || error.message?.includes('authentication failed')) userErrorMessage = `❌ ${error.message}`;

      console.log(`[experiment_setup_modal CRITICAL_ERROR_EDIT_REPLY ${interactionId}] Attempting critical error editReply...`); // Log change
      try {
           // Check if interaction is deferred/replied before editing
           if (interaction.deferred || interaction.replied) {
               // --- ACTION 1: Change to editReply ---
               await interaction.editReply({ content: userErrorMessage, components: [] });
               // --- End Action 1 ---
               console.log(`[experiment_setup_modal CRITICAL_ERROR_EDIT_REPLY_SUCCESS ${interactionId}] Sent critical error editReply.`); // Log change
           } else {
               // Should not happen if defer succeeds, but log if it does
               console.warn(`[experiment_setup_modal CRITICAL_ERROR_EDIT_REPLY_SKIP ${interactionId}] Interaction not deferred/replied. Cannot edit reply.`);
           }
      } catch (editError) {
         console.error(`[experiment_setup_modal CRITICAL_ERROR_EDIT_REPLY_FAIL ${interactionId}] Failed to send critical error editReply:`, editError); // Log change
      }
  }
  const modalProcessEndTime = performance.now();
  console.log(`[experiment_setup_modal END ${interactionId}] Processing finished. Total time: ${(modalProcessEndTime - modalSubmitStartTime).toFixed(2)}ms`);
}

    // --- START: NEW Unified Handler for Reminder Select Menus (Step 1: Window/Frequency) ---
    else if (interaction.isStringSelectMenu() && interaction.customId.startsWith('reminder_select_')) {
      const selectSubmitTime = performance.now();
      const interactionId = interaction.id; // For logging
      const userId = interaction.user.id;
      const menuId = interaction.customId;
      const selectedValue = interaction.values[0]; // Select menus (non-multi) always have one value

      console.log(`[ReminderSelect START ${interactionId}] User: ${userId} selected "${selectedValue}" for menu: ${menuId}. Time: ${selectSubmitTime.toFixed(2)}ms`);

      try {
          await interaction.deferUpdate({ flags: MessageFlags.Ephemeral });
          const deferTime = performance.now();
          console.log(`[ReminderSelect DEFERRED ${interactionId}] Interaction deferred. Took: ${(deferTime - selectSubmitTime).toFixed(2)}ms`);

          const setupData = userExperimentSetupData.get(userId);
          if (!setupData) {
              console.error(`[ReminderSelect CRITICAL ${interactionId}] Missing setup data for ${userId} on select menu interaction for ${menuId}.`);
              try {
                  await interaction.followUp({
                      content: "⚠️ Error: Couldn't retrieve your experiment setup data while saving reminder preference. Please start over using `/go`.",
                      ephemeral: true
                  });
              } catch (followUpError) {
                  console.error(`[ReminderSelect FALLBACK_ERROR ${interactionId}] Failed to send followUp error for missing setup data:`, followUpError);
              }
              return;
          }

          // Store the selected value based on the custom ID of the select menu
          switch (menuId) {
              case REMINDER_SELECT_START_HOUR_ID:
                  setupData.reminderStartHour = selectedValue;
                  console.log(`[ReminderSelect INFO ${interactionId}] Stored reminderStartHour: "${selectedValue}" for ${userId}.`);
                  break;
              case REMINDER_SELECT_END_HOUR_ID:
                  setupData.reminderEndHour = selectedValue;
                  console.log(`[ReminderSelect INFO ${interactionId}] Stored reminderEndHour: "${selectedValue}" for ${userId}.`);
                  break;
              case REMINDER_SELECT_FREQUENCY_ID:
                  setupData.reminderFrequency = selectedValue;
                  console.log(`[ReminderSelect INFO ${interactionId}] Stored reminderFrequency: "${selectedValue}" for ${userId}.`);
                  if (selectedValue === 'none') {
                      console.log(`[ReminderSelect INFO ${interactionId}] User ${userId} selected 'No Reminders'. Other reminder fields might be cleared or ignored later.`);
                  }
                  break;
              case REMINDER_SELECT_TIME_H_ID: // <<< ADDED CASE
                  setupData.reminderTimeH = selectedValue;
                  console.log(`[ReminderSelect INFO ${interactionId}] Stored reminderTimeH: "${selectedValue}" for ${userId}.`);
                  break;
              case REMINDER_SELECT_TIME_M_ID: // <<< ADDED CASE
                  setupData.reminderTimeM = selectedValue;
                  console.log(`[ReminderSelect INFO ${interactionId}] Stored reminderTimeM: "${selectedValue}" for ${userId}.`);
                  break;
              case REMINDER_SELECT_TIME_AP_ID: // <<< ADDED CASE
                  setupData.reminderTimeAP = selectedValue;
                  console.log(`[ReminderSelect INFO ${interactionId}] Stored reminderTimeAP: "${selectedValue}" for ${userId}.`);
                  break;
              default:
                  console.warn(`[ReminderSelect WARN ${interactionId}] Unrecognized reminder_select_ menu ID: ${menuId} for user ${userId}. Value: "${selectedValue}"`);
                  break;
          }

          userExperimentSetupData.set(userId, setupData);
          const loggedSetupData = JSON.parse(JSON.stringify(setupData)); // Deep clone for safe logging
          console.log(`[ReminderSelect DATA_UPDATED ${interactionId}] User: ${userId}. Current userExperimentSetupData state:`, loggedSetupData);

      } catch (error) {
          const errorTime = performance.now();
          console.error(`[ReminderSelect ERROR ${interactionId}] Error processing selection for ${menuId} for user ${userId} at ${errorTime.toFixed(2)}ms:`, error);
          try {
              await interaction.followUp({
                  content: `❌ An error occurred while saving your selection for ${menuId.replace('reminder_select_', '').replace(/_/g, ' ')}. Please try selecting again or restart with /go if issues persist.`,
                  ephemeral: true
              });
          } catch (followUpError) {
              console.error(`[ReminderSelect FALLBACK_ERROR ${interactionId}] Failed to send followUp error for select menu processing:`, followUpError);
          }
      }
      const processEndTime = performance.now();
      console.log(`[ReminderSelect END ${interactionId}] Finished processing ${menuId}. Total time: ${(processEndTime - selectSubmitTime).toFixed(2)}ms`);
    }
    // --- END: Unified Handler for Reminder Select Menus ---

  else if (interaction.isButton() && interaction.customId === REMINDERS_NEXT_STEP_BTN_ID) {
    const nextStepClickTime = performance.now();
    const interactionId = interaction.id;
    const userId = interaction.user.id;
    console.log(`[${interaction.customId} START ${interactionId}] Clicked by ${userId}. Preparing reminder step 2 (time selects) or finalizing if no reminders. Time: ${nextStepClickTime.toFixed(2)}ms`);

    try {
        await interaction.deferUpdate({ flags: MessageFlags.Ephemeral });
        const deferTime = performance.now();
        console.log(`[${interaction.customId} DEFERRED ${interactionId}] Interaction deferred. Took: ${(deferTime - nextStepClickTime).toFixed(2)}ms`);

        const setupData = userExperimentSetupData.get(userId);

        if (!setupData) {
            console.error(`[${interaction.customId} CRITICAL ${interactionId}] Missing setup data for user ${userId} when clicking 'Next' for reminders.`);
            await interaction.editReply({
                content: "⚠️ Error: Couldn't retrieve your experiment setup data. Please start over using `/go`.",
                embeds: [],
                components: []
            });
            return;
        }

        // Check if "No Reminders" was selected
        if (setupData.reminderFrequency === 'none') {
            console.log(`[${interaction.customId} INFO ${interactionId}] User ${userId} selected 'No Reminders'. Finalizing experiment setup without time prompt.`);

            const payload = {
                experimentDuration: setupData.experimentDuration,
                userCurrentTime: null,
                reminderWindowStartHour: null,
                reminderWindowEndHour: null,
                reminderFrequency: 'none',
                customReminderMessage: null, // Assuming no custom message input for this flow
                skippedReminders: true // Indicates reminders were intentionally skipped
            };

            console.log(`[${interaction.customId} FIREBASE_CALL ${interactionId}] Calling setExperimentSchedule for ${userId} (reminders skipped via 'Next'). Payload:`, payload);
            const scheduleResult = await callFirebaseFunction('setExperimentSchedule', payload, userId);

            if (scheduleResult && scheduleResult.success) {
                console.log(`[${interaction.customId} FIREBASE_SUCCESS ${interactionId}] setExperimentSchedule successful for ${userId} (reminders skipped).`);
                // The showPostToGroupPrompt function is expected to clean up userExperimentSetupData.get(userId)
                await showPostToGroupPrompt(interaction, setupData, "Reminders skipped as per your choice.", experimentSetupMotivationalMessages);
            } else {
                console.error(`[${interaction.customId} FIREBASE_FAIL ${interactionId}] setExperimentSchedule failed for ${userId} (reminders skipped). Result:`, scheduleResult);
                await interaction.editReply({
                    content: `⚠️ Could not finalize your experiment (reminders skipped): ${scheduleResult?.error || 'Unknown server error.'}. Your experiment settings and duration are saved. Please try `/go` again if you wished to set reminders.`,
                    embeds: [],
                    components: []
                });
            }
            return; // End processing for "No Reminders"
        }

        // Proceed to show time selection if reminders are being set
        // Validate that selections for step 1 (window and frequency) have been made
        if (!setupData.reminderStartHour || !setupData.reminderEndHour || !setupData.reminderFrequency) {
            console.error(`[${interaction.customId} VALIDATION_FAIL ${interactionId}] Missing data from reminder step 1 for ${userId}. Data:`, setupData);
            await interaction.editReply({
                content: "⚠️ Please make selections for Reminder Window Start Hour, End Hour, and Frequency from the dropdowns before proceeding to the next step.",
                embeds: [interaction.message.embeds[0]], // Keep the previous embed
                components: interaction.message.components // Keep the previous components for correction
            });
            return;
        }

        // --- Build Embed for Step 2 (Current Time Input) ---
        const timeEmbed = new EmbedBuilder()
            .setColor('#72418c') // Your secondary color
            .setTitle('⏰ Reminder Setup - Step 2 of 2')
            .setDescription(`Now, please select your **current local time**. This is crucial for the bot to understand your timezone and send reminders accurately.\n\nYour reminder window is set for ${setupData.reminderStartHour}:00 - ${setupData.reminderEndHour}:00 daily, with ${setupData.reminderFrequency.replace('_', ' ')} frequency.`)
            .addFields({ name: 'Current Time Needed:', value: 'So we can sync up times.' }) // Your updated explanation
            .setFooter({ text: 'Make selections for your current time below and confirm.' });

        // --- Build Step 2 Components (Time Selects + Final Confirm Button) ---

        // Time - Hour (1-12 for AM/PM)
        const timeHourSelect = new StringSelectMenuBuilder()
            .setCustomId(REMINDER_SELECT_TIME_H_ID) // Uses constant
            .setPlaceholder('Current time - HOUR (e.g., 2 PM)')
            .addOptions(
                Array.from({ length: 12 }, (_, i) => new StringSelectMenuOptionBuilder()
                    .setLabel(String(i + 1)) // 1 to 12
                    .setValue(String(i + 1)))
            );
        const rowTimeH = new ActionRowBuilder().addComponents(timeHourSelect);

        // Time - Minute (0-59, typically in increments for usability)
        const timeMinuteSelect = new StringSelectMenuBuilder()
            .setCustomId(REMINDER_SELECT_TIME_M_ID) // Uses constant
            .setPlaceholder('Current time - MINUTE (e.g., :30)')
            .addOptions(
                new StringSelectMenuOptionBuilder().setLabel('00').setValue('00'),
                new StringSelectMenuOptionBuilder().setLabel('15').setValue('15'),
                new StringSelectMenuOptionBuilder().setLabel('30').setValue('30'),
                new StringSelectMenuOptionBuilder().setLabel('45').setValue('45')
            );
        const rowTimeM = new ActionRowBuilder().addComponents(timeMinuteSelect);

        // Time - AM/PM
        const timeAmPmSelect = new StringSelectMenuBuilder()
            .setCustomId(REMINDER_SELECT_TIME_AP_ID) // Uses constant
            .setPlaceholder('Current time - AM or PM')
            .addOptions(
                new StringSelectMenuOptionBuilder().setLabel('AM').setValue('AM'),
                new StringSelectMenuOptionBuilder().setLabel('PM').setValue('PM')
            );
        const rowTimeAP = new ActionRowBuilder().addComponents(timeAmPmSelect);

        // Confirm Button (Final step)
        const confirmAllButton = new ButtonBuilder()
            .setCustomId(CONFIRM_REMINDER_BTN_ID) // Uses constant defined earlier
            .setLabel('Confirm All Reminder Settings')
            .setStyle(ButtonStyle.Success);
        const rowConfirm = new ActionRowBuilder().addComponents(confirmAllButton);

        console.log(`[${interaction.customId} EDIT_REPLY ${interactionId}] Editing reply to display reminder step 2 (time selects) for ${userId}.`);
        await interaction.editReply({
            content: 'Please select your current local time using the dropdowns below, then click confirm.',
            embeds: [timeEmbed],
            components: [rowTimeH, rowTimeM, rowTimeAP, rowConfirm] // Show Time H, M, AP selects + Confirm button
        });
        const editReplyTime = performance.now();
        console.log(`[${interaction.customId} EDIT_REPLY_SUCCESS ${interactionId}] Displayed reminder step 2 (time selects) for ${userId}. Took: ${(editReplyTime - deferTime).toFixed(2)}ms`);

    } catch (error) {
        const errorTime = performance.now();
        console.error(`[${interaction.customId} ERROR ${interactionId}] Error processing button for user ${userId} at ${errorTime.toFixed(2)}ms:`, error);
        try {
            if (interaction.deferred || interaction.replied) {
                await interaction.editReply({ // Use editReply as it was deferred
                    content: '❌ Error preparing the current time selection step. Please try clicking "Next" again or restart with /go.',
                    embeds: [],
                    components: []
                });
            } else {
                console.warn(`[${interaction.customId} ERROR_NO_EDIT ${interactionId}] Interaction not editable for error message.`);
            }
        } catch (editError) { // Fallback if editReply fails
            console.error(`[${interaction.customId} FALLBACK_ERROR ${interactionId}] Fallback error reply failed for ${userId}:`, editError);
            try {
                await interaction.followUp({content: '❌ Error preparing the current time selection step. Please try clicking "Next" again.', ephemeral: true });
            } catch (followUpErrorInner) {
                console.error(`[${interaction.customId} FALLBACK_ERROR_INNER ${interactionId}] Inner fallback error followup failed for ${userId}:`, followUpErrorInner);
            }
        }
    }
    const processEndTime = performance.now();
    console.log(`[${interaction.customId} END ${interactionId}] Finished processing. Total time: ${(processEndTime - nextStepClickTime).toFixed(2)}ms`);
    }
    // --- END: NEW Handler for Reminder Step 2 Button ---

  // --- START: NEW Handler for Final Confirm Reminder Button (CONFIRM_REMINDER_BTN_ID) ---
  else if (interaction.isButton() && interaction.customId === CONFIRM_REMINDER_BTN_ID) {
    const confirmClickTime = performance.now();
    const interactionId = interaction.id;
    const userId = interaction.user.id;
    console.log(`[${interaction.customId} START ${interactionId}] Clicked by ${userId}. Finalizing reminder setup. Time: ${confirmClickTime.toFixed(2)}ms`);

    try {
        await interaction.deferUpdate({ flags: MessageFlags.Ephemeral }); // Acknowledge button click
        const deferTime = performance.now();
        console.log(`[${interaction.customId} DEFERRED ${interactionId}] Interaction deferred. Took: ${(deferTime - confirmClickTime).toFixed(2)}ms`);

        const setupData = userExperimentSetupData.get(userId);

        // --- Validation: Check if all required selections are made ---
        // Also need experimentDuration from the very first steps.
        const requiredKeys = [
            'experimentDuration', // From earlier step
            'reminderStartHour',
            'reminderEndHour',
            'reminderFrequency',
            'reminderTimeH',      // Current Time Hour
            'reminderTimeM',      // Current Time Minute
            'reminderTimeAP'      // Current Time AM/PM
        ];

        if (!setupData) {
            console.error(`[${interaction.customId} CRITICAL ${interactionId}] Missing setupData entirely for user ${userId}.`);
            await interaction.editReply({
                content: `⚠️ Error: Could not retrieve any of your experiment setup data. Please start over with \`/go\`.`,
                embeds: [],
                components: []
            });
            return;
        }

        const missingKeys = requiredKeys.filter(key => !setupData[key]); // Simpler check for undefined/null

        if (missingKeys.length > 0) {
            console.error(`[${interaction.customId} VALIDATION_FAIL ${interactionId}] Missing required selections for ${userId}. Missing: ${missingKeys.join(', ')}. Data:`, setupData);
            await interaction.editReply({
                content: `⚠️ Please ensure you have selected values for all reminder options, including your current time. Missing: \`${missingKeys.join(', ')}\`. Go back and make selections from the dropdowns.`,
                embeds: [interaction.message.embeds[0]], // Keep the current "Set Current Time" embed
                components: interaction.message.components // Keep existing selects/button for correction
            });
            return;
        }

        // --- Reconstruct Current Time String (e.g., "2:30 PM") ---
        // The backend 'setExperimentSchedule' expects a single string for userCurrentTime.
        const reconstructedTime = `${setupData.reminderTimeH}:${setupData.reminderTimeM} ${setupData.reminderTimeAP}`;
        console.log(`[${interaction.customId} INFO ${interactionId}] Reconstructed current time for ${userId}: "${reconstructedTime}"`);

        // --- Validation: Check Start/End Hour Logic ---
        const startHour24 = parseInt(setupData.reminderStartHour, 10); // Values are "00" - "23"
        const endHour24 = parseInt(setupData.reminderEndHour, 10);     // Values are "00" - "23"

        // Convert to 12-hour format with AM/PM for user-facing messages
        const formatHourForDisplay = (hour24) => {
            const hour12 = hour24 % 12 === 0 ? 12 : hour24 % 12;
            const period = hour24 < 12 || hour24 === 24 ? 'AM' : 'PM'; // 24 is midnight AM (next day start)
            if (hour24 === 0) return '12 AM (Midnight)'; // Special case for midnight display
            return `${hour12} ${period}`;
        };

        // If endHour is 0 (midnight), it's effectively the end of the day, so it's "greater" than any start hour for validation.
        // The check should be: if endHour is NOT midnight (0), then startHour must be less than endHour.
        if (endHour24 !== 0 && startHour24 >= endHour24) {
            console.warn(`[${interaction.customId} VALIDATION_FAIL ${interactionId}] Invalid time window for ${userId}: Start ${startHour24} >= End ${endHour24} (and End is not Midnight).`);
            await interaction.editReply({
                content: `⚠️ Reminder window end time (${formatHourForDisplay(endHour24)}) must be after the start time (${formatHourForDisplay(startHour24)}), unless the end time is midnight (12 AM). Please go back and correct your selections using the "Set Reminders" button again from the previous step (you might need to restart the /go flow if navigation is tricky).`,
                embeds: [interaction.message.embeds[0]], // Keep current embed
                components: interaction.message.components // Keep current components
            });
            return;
        }

        // --- Prepare Payload for Firebase 'setExperimentSchedule' ---
        const payload = {
            experimentDuration: setupData.experimentDuration,
            userCurrentTime: reconstructedTime,
            reminderWindowStartHour: setupData.reminderStartHour, // e.g., "09"
            reminderWindowEndHour: setupData.reminderEndHour,     // e.g., "17"
            reminderFrequency: setupData.reminderFrequency,       // e.g., "daily_1"
            customReminderMessage: null, // As decided, no custom message input in this flow
            skippedReminders: false     // Explicitly false as they went through setup
        };

        console.log(`[${interaction.customId} FIREBASE_CALL ${interactionId}] Calling setExperimentSchedule for ${userId}. Payload:`, payload);
        const scheduleResult = await callFirebaseFunction('setExperimentSchedule', payload, userId);

        if (scheduleResult && scheduleResult.success) {
            console.log(`[${interaction.customId} FIREBASE_SUCCESS ${interactionId}] setExperimentSchedule successful for ${userId}.`);
            // Proceed to "Post to group?" prompt
            const reminderSummary = setupData.reminderFrequency === 'none' // Should not happen here as 'none' skips to this point.
                ? "No reminders set (this is unexpected here)." // Fallback
                : `Reminders set for ${setupData.reminderFrequency.replace(/_/g, ' ')} between ${formatHourForDisplay(startHour24)} - ${formatHourForDisplay(endHour24)} (your local time approx, based on current time provided).`;

            await showPostToGroupPrompt(interaction, setupData, reminderSummary, experimentSetupMotivationalMessages);
            // userExperimentSetupData.delete(userId) will be handled by showPostToGroupPrompt or its button handlers
        } else {
            console.error(`[${interaction.customId} FIREBASE_FAIL ${interactionId}] setExperimentSchedule failed for ${userId}. Result:`, scheduleResult);
            await interaction.editReply({
                content: `⚠️ Could not save your reminder settings: ${scheduleResult?.error || 'Unknown server error.'}. Your experiment settings (problem, inputs, output) and duration are saved. You may need to try setting reminders again via \`/go\`.`,
                embeds: [],
                components: []
            });
        }

    } catch (error) {
        const errorTime = performance.now();
        console.error(`[${interaction.customId} ERROR ${interactionId}] Error processing confirmation for ${userId} at ${errorTime.toFixed(2)}ms:`, error);
        try {
            if (interaction.deferred || interaction.replied) {
                await interaction.editReply({ // Use editReply as it was deferred
                    content: `❌ An error occurred while saving your reminder settings: ${error.message || 'Unknown error'}. Please try again.`,
                    embeds: [],
                    components: []
                });
            } else {
                console.warn(`[${interaction.customId} ERROR_NO_EDIT ${interactionId}] Interaction not editable for error message.`);
            }
        } catch (editError) {
            console.error(`[${interaction.customId} FALLBACK_ERROR ${interactionId}] Fallback error reply failed for ${userId}:`, editError);
            try {
                await interaction.followUp({content: `❌ An error occurred while saving reminder settings: ${error.message || 'Unknown error'}.`, ephemeral: true });
            } catch (followUpErrorInner) {
                console.error(`[${interaction.customId} FALLBACK_ERROR_INNER ${interactionId}] Inner fallback error followup failed for ${userId}:`, followUpErrorInner);
            }
        }
    }
    const processEndTime = performance.now();
    console.log(`[${interaction.customId} END ${interactionId}] Finished processing confirmation. Total time: ${(processEndTime - confirmClickTime).toFixed(2)}ms`);
  }
  // --- END: NEW Handler for Final Confirm Reminder Button ---

  // --- START: NEW Handler for Duration Select Menu Interaction ---
  else if (interaction.isStringSelectMenu() && interaction.customId === 'experiment_duration_select') {
    const selectMenuSubmitTime = performance.now();
    const interactionId = interaction.id;
    console.log(`[experiment_duration_select START ${interactionId}] Received selection from ${interaction.user.tag}.`);

    try {
        // --- ACTION 1: Defer Update ---
        await interaction.deferUpdate({ flags: MessageFlags.Ephemeral }); // Keep it ephemeral
        const deferTime = performance.now();
        console.log(`[experiment_duration_select DEFERRED ${interactionId}] Interaction deferred. Took: ${(deferTime - selectMenuSubmitTime).toFixed(2)}ms`);

        // --- ACTION 2: Get Selected Value ---
        const selectedDuration = interaction.values[0];
        console.log(`[experiment_duration_select DATA ${interactionId}] Selected duration value: "${selectedDuration}"`);

        // --- ACTION 3: Retrieve Stored Setup Data ---
        const setupData = userExperimentSetupData.get(interaction.user.id);
        if (!setupData) {
            console.error(`[experiment_duration_select CRITICAL ${interactionId}] Missing setup data for user ${interaction.user.id}.`);
            await interaction.editReply({
                content: "⚠️ Error: Could not retrieve your initial experiment settings. Please start over using `/go`.",
                embeds: [],
                components: []
            });
            return;
        }

        // --- ACTION 4: Store Duration and Update Map ---
        setupData.experimentDuration = selectedDuration;
        userExperimentSetupData.set(interaction.user.id, setupData);
        console.log(`[experiment_duration_select DATA_STORED ${interactionId}] Stored duration: ${selectedDuration}`);

        // --- ACTION 5: Show Reminder Buttons (Edit the message again) ---
        // This part confirms your point 5: it leads to the reminder buttons.
        const reminderButtons = new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder().setCustomId('show_reminders_setup_modal_btn').setLabel('⏰ Set Reminders').setStyle(ButtonStyle.Primary),
                new ButtonBuilder().setCustomId('skip_reminders_btn').setLabel('🔕 No Reminders').setStyle(ButtonStyle.Secondary)
            );

        console.log(`[experiment_duration_select EDIT_REPLY ${interactionId}] Editing reply to show reminder buttons.`);
        await interaction.editReply({
            content: `✅ Duration set to **${selectedDuration.replace('_', ' ')}**. Want to set up reminders for your daily logs?`,
            embeds: [],
            components: [reminderButtons]
        });
        console.log(`[experiment_duration_select EDIT_REPLY_SUCCESS ${interactionId}] Successfully showed reminder buttons.`);

    } catch (error) {
        const errorTime = performance.now();
        console.error(`[experiment_duration_select ERROR ${interactionId}] Error processing selection at ${errorTime.toFixed(2)}ms:`, error);
        try {
            await interaction.editReply({
                content: '❌ An error occurred while processing your duration selection. Please try selecting again.',
                embeds: [],
                components: []
            });
        } catch (editError) {
            console.error(`[experiment_duration_select FALLBACK_ERROR ${interactionId}] Failed to send error editReply:`, editError);
        }
    }
    const selectMenuProcessEndTime = performance.now();
    console.log(`[experiment_duration_select END ${interactionId}] Processing finished. Total time: ${(selectMenuProcessEndTime - selectMenuSubmitTime).toFixed(2)}ms`);
  }
  // --- END: NEW Handler for Duration Select Menu Interaction ---

  else if (interaction.isButton() && interaction.customId === 'show_reminders_setup_modal_btn') {
      const buttonClickTime = performance.now();
      const interactionId = interaction.id;
      const userId = interaction.user.id;
      console.log(`[${interaction.customId} START ${interactionId}] Clicked by ${userId}. Preparing reminder selection message (Step 1). Time: ${buttonClickTime.toFixed(2)}ms`);

      try {
          await interaction.deferUpdate({ flags: MessageFlags.Ephemeral }); // Acknowledge button click and allow editing the message
          const deferTime = performance.now();
          console.log(`[${interaction.customId} DEFERRED ${interactionId}] Interaction deferred. Took: ${(deferTime - buttonClickTime).toFixed(2)}ms`);

          const setupData = userExperimentSetupData.get(userId);
          if (!setupData) {
              console.error(`[${interaction.customId} CRITICAL ${interactionId}] Missing setup data for user ${userId}.`);
              await interaction.editReply({
                  content: "⚠️ Error: Couldn't retrieve your previous experiment setup steps (like duration). Please start over using `/go`.",
                  embeds: [],
                  components: []
              });
              return;
          }
          if (!setupData.experimentDuration) {
              console.error(`[${interaction.customId} CRITICAL ${interactionId}] Missing experimentDuration in setup data for user ${userId}. Data:`, setupData);
              await interaction.editReply({
                  content: "⚠️ Error: Experiment duration is missing from your setup. Please select duration again or start over with `/go`.",
                  embeds: [],
                  components: []
              });
              return;
          }

          // --- Build Reminder Setup Embed (Step 1) ---
          const reminderEmbedStep1 = new EmbedBuilder()
              .setColor('#72418c') // Your secondary color preference
              .setTitle('⏰ Reminder Setup - Step 1 of 2')
              .setDescription('First, set your **daily reminder window** (when reminders are allowed) and their **frequency**.\nThen click "Next" to set your current time for timezone synchronization.')
              .addFields(
                  { name: 'Reminder Window (e.g., 9 AM - 5 PM)', value: 'Reminders will only be sent between these hours in your local time.', inline: false },
                  { name: 'Frequency', value: 'How often you receive reminders within that window.', inline: false }
              )
              .setFooter({ text: 'Make selections below, then click Next.' });

          // --- Build Step 1 Components: Window (Start/End) & Frequency Selects + Next Button ---

          // Start Hour Select Menu
          const startHourSelect = new StringSelectMenuBuilder()
              .setCustomId(REMINDER_SELECT_START_HOUR_ID) // Uses constant
              .setPlaceholder('Reminder window START hour')
              .addOptions(
                  Array.from({ length: 24 }, (_, i) => {
                      const hour12 = i % 12 === 0 ? 12 : i % 12;
                      const period = i < 12 ? 'AM' : 'PM';
                      return new StringSelectMenuOptionBuilder()
                          .setLabel(`${hour12} ${period} (${String(i).padStart(2, '0')}:00)`)
                          .setValue(String(i).padStart(2, '0')); // e.g., "00", "01", ..., "23"
                  })
              );
          const rowStartHour = new ActionRowBuilder().addComponents(startHourSelect);

          // End Hour Select Menu
          const endHourSelect = new StringSelectMenuBuilder()
              .setCustomId(REMINDER_SELECT_END_HOUR_ID) // Uses constant
              .setPlaceholder('Reminder window END hour')
              .addOptions(
                  Array.from({ length: 24 }, (_, i) => {
                      const hour12 = i % 12 === 0 ? 12 : i % 12;
                      const period = i < 12 ? 'AM' : 'PM';
                      // Option for "next day" for end hour could be added if desired, e.g. 2 AM next day for a 10 PM start.
                      // For simplicity, keeping it within the same 24hr cycle for now. "00" means end of day.
                      return new StringSelectMenuOptionBuilder()
                          .setLabel(`${hour12} ${period} (${String(i).padStart(2, '0')}:00)`)
                          .setValue(String(i).padStart(2, '0'));
                  })
              );
          const rowEndHour = new ActionRowBuilder().addComponents(endHourSelect);

          // Frequency Select Menu
          const freqSelect = new StringSelectMenuBuilder()
              .setCustomId(REMINDER_SELECT_FREQUENCY_ID) // Uses constant
              .setPlaceholder('How often for reminders?')
              .addOptions(
                  new StringSelectMenuOptionBuilder().setLabel('No Reminders').setValue('none').setDescription("I'll log on my own. Skips next step."), // Clarify skip
                  new StringSelectMenuOptionBuilder().setLabel('Once a day').setValue('daily_1').setDescription('One random reminder per day within window.'),
                  new StringSelectMenuOptionBuilder().setLabel('Twice a day').setValue('daily_2').setDescription('Two random reminders per day within window.'),
                  new StringSelectMenuOptionBuilder().setLabel('Every other day').setValue('every_other_day').setDescription('One random reminder, every other day.')
              );
          const rowFreq = new ActionRowBuilder().addComponents(freqSelect);

          // Next Button
          const nextButton = new ButtonBuilder()
              .setCustomId(REMINDERS_NEXT_STEP_BTN_ID) // Uses new constant
              .setLabel('Next: Set Current Time')
              .setStyle(ButtonStyle.Primary);
          // We'll add this button to the last row of selects to save space if needed,
          // but Discord allows up to 5 Action Rows. We have 3 rows of selects and 1 for the button. This is fine.
          const rowNextButton = new ActionRowBuilder().addComponents(nextButton);


          console.log(`[${interaction.customId} EDIT_REPLY ${interactionId}] Editing reply to display reminder step 1 (window/frequency)...`);
          await interaction.editReply({
              content: 'Configure your reminder window and frequency below. If you select "No Reminders", these settings will be skipped when you click "Next".',
              embeds: [reminderEmbedStep1],
              components: [rowStartHour, rowEndHour, rowFreq, rowNextButton] // Show first 3 selects + Next button
          });
          const editReplyTime = performance.now();
          console.log(`[${interaction.customId} EDIT_REPLY_SUCCESS ${interactionId}] Displayed reminder step 1 (window/freq) for ${userId}. Took: ${(editReplyTime - deferTime).toFixed(2)}ms.`);

      } catch (error) {
          const errorTime = performance.now();
          console.error(`[${interaction.customId} ERROR ${interactionId}] Error processing button for ${userId} at ${errorTime.toFixed(2)}ms:`, error);
          // Try to edit the deferred update with an error message
          try {
              // Check if interaction is still editable
              if (interaction.deferred || interaction.replied) {
                  await interaction.editReply({
                      content: '❌ Error showing reminder setup (Step 1). Please try clicking "Set Reminders" again.',
                      embeds: [],
                      components: []
                  });
              } else {
                  console.warn(`[${interaction.customId} ERROR_NO_EDIT ${interactionId}] Interaction not editable for error message.`);
              }
          } catch (editError) {
              console.error(`[${interaction.customId} FALLBACK_ERROR ${interactionId}] Fallback error reply failed:`, editError);
              // If editReply fails, a followUp might be possible if the interaction token is still valid,
              // but it creates a new message which might be confusing. Logging is the main goal here.
          }
      }
      const processEndTime = performance.now();
      console.log(`[${interaction.customId} END ${interactionId}] Finished processing. Total time: ${(processEndTime - buttonClickTime).toFixed(2)}ms`);
   }

  // Button handler for "Skip Reminders"
  else if (interaction.isButton() && interaction.customId === 'skip_reminders_btn') {
    console.log(`[skip_reminders_btn] Clicked by ${interaction.user.tag}`);
    await interaction.deferUpdate(); // Acknowledge the button click

    const userId = interaction.user.id;
    const setupData = userExperimentSetupData.get(userId);

    if (!setupData || !setupData.settingsMessage || !setupData.experimentDuration) {
      console.error(`[skip_reminders_btn] Critical: Missing setup data for ${userId}`);
      await interaction.editReply({ content: "⚠️ Error: Could not retrieve your experiment settings to finalize. Please start over with `/go`.", components: [] });
      return;
    }

    const payload = {
      experimentDuration: setupData.experimentDuration,
      userCurrentTime: null, // Explicitly null or omitted
      reminderWindowStartHour: null,
      reminderWindowEndHour: null,
      reminderFrequency: 'none', // Explicitly 'none'
      customReminderMessage: null,
      skippedReminders: true
    };

    console.log(`[skip_reminders_btn] Calling setExperimentSchedule for ${userId} with skipped reminders. Payload:`, payload);
    try {
      const scheduleResult = await callFirebaseFunction('setExperimentSchedule', payload, userId);

      if (scheduleResult && scheduleResult.success) {
        console.log(`[skip_reminders_btn] setExperimentSchedule successful for ${userId} (reminders skipped).`);
        // Proceed to "Post to group?" prompt
        await showPostToGroupPrompt(interaction, setupData, "Reminders skipped as per your choice.", experimentSetupMotivationalMessages);
      } else {
        console.error(`[skip_reminders_btn] setExperimentSchedule failed for ${userId} (reminders skipped). Result:`, scheduleResult);
        await interaction.editReply({ content: `⚠️ Could not finalize experiment (reminders skipped): ${scheduleResult ? scheduleResult.error : 'Unknown server error.'}. Your experiment settings and duration are saved.`, components: [] });
      }
    } catch (error) {
      console.error(`[skip_reminders_btn] Error calling setExperimentSchedule for ${userId} (reminders skipped):`, error);
      await interaction.editReply({ content: `❌ An error occurred while finalizing your experiment (reminders skipped): ${error.message}. Your experiment settings and duration are saved.`, components: [] });
    }
  }

   // Button handlers for the FINAL "Post to group?"
  else if (interaction.isButton() && interaction.customId === 'post_exp_final_yes') {
      await interaction.deferUpdate(); // Acknowledge button
      const userId = interaction.user.id;
      const setupData = userExperimentSetupData.get(userId);

      if (!setupData || !setupData.settingsMessage || !setupData.rawPayload) {
          await interaction.editReply({ content: "⚠️ Error: Could not retrieve experiment details to post. Your settings are saved.", components: [] });
          return;
      }

      const experimentsChannelId = '1371540356935712788'; // Test group #experiments
      // TODO: Change to production #experiments channel ID: '1364283719296483329'
      const channel = interaction.guild.channels.cache.get(experimentsChannelId);

      if (channel && channel.isTextBased()) {
          try {
              const { deeperProblem, outputSetting, inputSettings } = setupData.rawPayload;
              const postEmbed = new EmbedBuilder()
                  .setColor('#7289DA')
                  .setTitle(`🚀 ${interaction.user.username} is starting a new experiment!`)
                  .setDescription(`**🎯 Deeper Problem:**\n${deeperProblem}`)
                  .addFields(
                      { name: '📊 Output to Track', value: outputSetting || "Not specified" },
                      { name: '🧪 Input 1', value: inputSettings[0] || "Not specified" }
                  )
                  .setFooter({text: `Let's support them! Duration: ${setupData.experimentDuration.replace('_',' ')}`})
                  .setTimestamp();
              if (inputSettings[1]) {
                  postEmbed.addFields({ name: '🧪 Input 2', value: inputSettings[1], inline: true });
              }
              if (inputSettings[2]) {
                  postEmbed.addFields({ name: '🧪 Input 3', value: inputSettings[2], inline: true });
              }

              await channel.send({ embeds: [postEmbed] });
              await interaction.editReply({ content: `✅ Shared to the #experiments channel!`, components: [] });
          } catch (postError) {
              console.error(`[post_exp_final_yes] Error posting to channel ${experimentsChannelId}:`, postError);
              await interaction.editReply({ content: "⚠️ Could not post to the #experiments channel. Please check my permissions there. Your settings are saved.", components: [] });
          }
      } else {
          await interaction.editReply({ content: "⚠️ Could not find the #experiments channel to post. Your settings are saved.", components: [] });
      }
      userExperimentSetupData.delete(userId); // Clean up
   }
   else if (interaction.isButton() && interaction.customId === 'post_exp_final_no') {
      await interaction.update({
          content: "👍 Got it! Your experiment is all set and kept private. Good luck!",
          components: []
      });
      userExperimentSetupData.delete(interaction.user.id); // Clean up
  }

// ****** END: Add these NEW Modal and Button Handlers (Step 2 Flow) ******

console.log(`--- InteractionCreate END [${interactionId}] ---\n`);

}); // end of client.on(Events.InteractionCreate)


// Helper functions outside the interaction handler
async function handleRoleUpdate(interaction, streakCount, result) {
  try {
    const guild = interaction.guild;
    const member = interaction.member;
    
    // Get all existing streak roles from the user
    const existingRoles = member.roles.cache.filter(role => 
      role.tags?.botId === client.user.id  // Roles created by this bot
    );

    // Remove any existing streak roles
    for (const [_, role] of existingRoles) {
      await member.roles.remove(role.id);
    }

    // Create and assign the new role if roleInfo is provided
    if (result.roleInfo) {
      const newRole = await ensureRole(guild, result.roleInfo.name, result.roleInfo.color);
      await member.roles.add(newRole.id);
    }
  } catch (error) {
    console.error('Error in handleRoleUpdate:', error);
  }
}

// In Render/index.js (Place these outside the InteractionCreate handler)

/**
 * Ensures a role exists in the guild, creating it if necessary.
 * @param {Guild} guild - The guild object.
 * @param {string} roleName - The desired role name.
 * @param {import('discord.js').ColorResolvable} [color] - Optional color for the role.
 * @returns {Promise<import('discord.js').Role>} The found or created role.
 */
async function ensureRole(guild, roleName, color) {
  if (!guild) throw new Error("Guild is required for ensureRole.");
  if (!roleName) throw new Error("Role name is required for ensureRole.");

  try {
    // Attempt to find the role by name
    let role = guild.roles.cache.find(r => r.name === roleName);

    if (!role) {
      console.log(`Role "${roleName}" not found in cache, attempting to fetch...`);
      // If not in cache, fetch all roles and try again (more robust)
      await guild.roles.fetch();
      role = guild.roles.cache.find(r => r.name === roleName);
    }

    if (!role) {
      console.log(`Role "${roleName}" not found, creating...`);
      // If still not found, create it
      role = await guild.roles.create({
        name: roleName,
        color: color, // Use provided color or default
        permissions: [], // No permissions needed for cosmetic roles
        reason: `Creating role for bot feature (e.g., streaks, freezes).`,
      });
      console.log(`Role "${roleName}" created successfully.`);
    }
    return role;
  } catch (error) {
    console.error(`Error finding or creating role "${roleName}" in guild ${guild.id}:`, error);
    // Rethrow or handle as appropriate for your error strategy
    throw new Error(`Failed to ensure role "${roleName}": ${error.message}`);
  }
}

client.login(DISCORD_TOKEN).catch(err => {
  console.error('❌ Failed to login to Discord:', err);
  process.exit(1);
});