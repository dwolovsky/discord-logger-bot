// ==================================
//      STREAK CONFIGURATION
// ==================================

const STREAK_CONFIG = {
    // Using field names from Firestore 'users' collection directly
    FIELDS: {
        CURRENT_STREAK: 'currentStreak',
        LONGEST_STREAK: 'longestStreak',
        LAST_LOG_TIMESTAMP: 'lastLogTimestamp',
        FREEZES_REMAINING: 'freezesRemaining',
        USER_TAG: 'userTag',
        PENDING_ROLE_UPDATE: 'pendingRoleUpdate',     // For regular streak roles
        PENDING_DM_MESSAGE: 'pendingDmMessage',       // For DMs (milestones, freeze awards, streak resets)
        PENDING_FREEZE_ROLE_UPDATE: 'pendingFreezeRoleUpdate', // For "❄️ Freezes: X" role name
        PENDING_ROLE_CLEANUP: 'pendingRoleCleanup',         // Boolean, true if non-Originator streak roles should be removed on reset
        PENDING_PUBLIC_MESSAGE: 'pendingPublicMessage'    // For specific public announcements like streak reset
        // LAST_FREEZE_DATE: 'lastFreezeDate', // Can be re-added if detailed freeze tracking is needed
        // FROZEN_DATES: 'frozenDates'       // Can be re-added if detailed freeze tracking is needed
    },
    TIMING_RULES: {
        SAME_DAY_HOURS: 17, // Less than 17 hours since last log = same log day (streak doesn't advance)
        MAX_CONSECUTIVE_HOURS: 30 // Less than or equal to 30 hours since last log = consecutive day (streak advances)
        // More than 30 hours = gap (check freezes)
    },
    MILESTONES: {
        // Days when a freeze stack is awarded
        FREEZE_AWARD_DAYS: [15, 30, 60, 90, 120, 150, 180, 210, 240, 270, 300, 330, 360, 390, 420, 450, 480, 510, 540, 570, 600, 630, 660, 690, 720, 750, 780, 810, 840, 870, 900, 930, 960, 990, 1020],
        // Base name for freeze roles. The bot will create/manage roles like "❄️ Freezes: 0", "❄️ Freezes: 1", etc.
        FREEZE_ROLE_BASENAME: '❄️ Freezes',
        // Role definitions based on streak days reached
        ROLES: [
            // NOTE: Ensure these names match desired Discord role names if the bot is to create them.
            { name: 'Originator', days: 1, color: '#FFB3B3' },      // Light red
            { name: 'Mover', days: 15, color: '#FF6666' },         // Medium red
            { name: 'Navigator', days: 30, color: '#FF0000' },          // Bright red
            { name: 'Signal', days: 60, color: '#CC0000' },          // Deep red
            { name: 'Centurion', days: 100, color: '#990000' },         // Dark red
            { name: 'Vector', days: 150, color: '#FFD1B3' },         // Light orange
            { name: 'Blaster', days: 200, color: '#FFA366' },           // Medium orange
            { name: 'Corona', days: 250, color: '#FF8000' },   // Bright orange
            { name: 'Luminary', days: 300, color: '#CC6600' },    // Deep orange
            { name: 'Orbiter', days: 365, color: '#FFF4B3' },   // Light yellow
            { name: 'Radiance', days: 400, color: '#FFE666' },     // Medium yellow
            { name: 'Pulsar', days: 450, color: '#FFD700' },   // Bright yellow
            { name: 'Quantum', days: 500, color: '#B3FFB3' },     // Light green
            { name: 'Zenith', days: 550, color: '#66FF66' },       // Medium green
            { name: 'Nexus', days: 600, color: '#00FF00' },      // Bright green
            { name: 'Paragon', days: 650, color: '#009900' },           // Deep green
            { name: 'Supernova', days: 700, color: '#B3B3FF' },      // Light blue
            { name: 'Axiom', days: 750, color: '#6666FF' },    // Medium blue
            { name: 'Oracle', days: 800, color: '#0000FF' },          // Bright blue
            { name: 'Divinator', days: 850, color: '#000099' }, // Deep blue
            { name: 'Cosmic', days: 900, color: '#D1B3FF' }, // Light purple
            { name: 'Infinity', days: 950, color: '#9933FF' }, // Medium purple
            { name: 'Transcendent', days: 1000, color: '#4B0082' } // Deep purple/indigo
        ]
    },
    MESSAGES: {
        DM: {
            FREEZE_AWARD: '❄️ STREAK FREEZE AWARDED for reaching ${streak} days!',
            ROLE_ACHIEVEMENT: '🏆 Congratulations! You\'ve earned the ${roleName} title!',
            STREAK_RESET: "Look at your grit!!!\nYou've just proven you care more about your personal transformation than the dopamine spike of +1 to your streak.\n\n"
        },
        PUBLIC: { // Bot replaces ${userTag} with the actual user tag for public announcements
            STREAK_RESET: '${userTag} has GRIT beyond streaks! They just broke their streak and restarted 🙌🏼. We\'re not worthy!'
            // Add other public message templates here if needed later
        }
    },
    FREEZES: {
      MAX: 5, // Max number of freezes a user can hold
      AUTO_APPLY: true // Assumes freezes are auto-applied if available and needed
    }
};
// ==================================

// Gen 2 Imports
const { onCall, HttpsError, onRequest } = require("firebase-functions/v2/https");
const { onDocumentCreated } = require("firebase-functions/v2/firestore");
const { logger } = require("firebase-functions"); // Use the shared v2 logger
const admin = require("firebase-admin");
const { FieldValue } = require("firebase-admin/firestore");

// Initialize the Firebase Admin SDK
admin.initializeApp();

// --- Cloud Functions (Gen 2 Syntax) ---

/**
 * Creates a Firebase Custom Auth Token for the given Discord User ID.
 * Called by the Discord bot frontend.
 * Expects data payload: { userId: "DISCORD_USER_ID" }
 * Returns: { token: "FIREBASE_CUSTOM_TOKEN" } on success.
 */
exports.getFirebaseAuthToken = onCall(async (request) => {
  // Gen 2: Access data via request.data
  // Gen 2: Access auth context (if authenticated) via request.auth
  // --- IMPORTANT SECURITY NOTE --- Add verification later ---

  const userId = request.data.userId;
  if (!userId) {
    // Gen 2: Throw HttpsError directly
    throw new HttpsError(
      'invalid-argument',
      'The function must be called with a `userId` in the data payload.'
    );
  }

  // Gen 2: Use imported logger
  logger.log(`Attempting to create token for userId: ${userId}`);
  try {
    const customToken = await admin.auth().createCustomToken(userId);
    logger.log(`Successfully created token for userId: ${userId}`);
    return { token: customToken };
  } catch (error) {
    logger.error("Error creating custom token for userId:", userId, error);
    throw new HttpsError(
      'internal',
      'Could not create custom token.',
      error.message
    );
  }
});

exports.submitLog = onRequest( // Renaming back to submitLog for simplicity, ensure URL is updated later
    { cors: true }, // Allows requests from any origin. Required for web clients, good for bot too.
    async (request, response) => {
      // 1. Check Method
      if (request.method !== 'POST') {
        logger.warn(`submitLog (HTTP): Method ${request.method} not allowed.`);
        response.status(405).json({ success: false, error: 'Method Not Allowed', code: 'method-not-allowed' });
        return;
      }
  
      // 2. Check Authorization Header and Verify Firebase ID Token
      const authorizationHeader = request.headers.authorization;
      if (!authorizationHeader || !authorizationHeader.startsWith('Bearer ')) {
        logger.warn("submitLog (HTTP): Called without or with malformed Bearer token.");
        response.status(401).json({ success: false, error: 'Unauthorized - No token provided or malformed.', code: 'no-bearer-token' });
        return;
      }
  
      const idToken = authorizationHeader.split('Bearer ')[1];
      let decodedToken;
      try {
        decodedToken = await admin.auth().verifyIdToken(idToken);
        // logger.info("submitLog (HTTP): Successfully verified ID token for UID:", decodedToken.uid); // Optional: log on success
      } catch (error) {
        logger.error("submitLog (HTTP): Error verifying Firebase ID token:", {
          errorMessage: error.message,
          errorCode: error.code,
          tokenPresent: !!idToken,
        });
        // Provide a generic error message but log specifics
        response.status(401).json({ success: false, error: 'Unauthorized - Invalid or expired token.', code: 'invalid-token' });
        return;
      }
  
      // 3. Extract User Info and Payload
      const userId = decodedToken.uid;
      const userTag = decodedToken.name || `User_${userId}`; // Use 'name' claim if available in token
      const { inputValues, outputValue, notes } = request.body; // Data from request.body
  
      logger.info(`submitLog (HTTP): Processing request for user: ${userId} (${userTag})`);
      logger.debug("submitLog (HTTP): Received payload:", request.body);
  
      // 4. Your Adapted Core Logic (from original onCall function)
      const db = admin.firestore();
      try {
        // --- Basic Payload Validation ---
        if (!Array.isArray(inputValues) || inputValues.length !== 3 || outputValue == null || notes == null) {
          logger.warn("submitLog (HTTP): Invalid payload structure.", { userId });
          // Send 400 Bad Request
          response.status(400).json({ success: false, error: 'Missing required log data fields (inputValues[3], outputValue, notes).', code: 'invalid-payload-structure'});
          return;
        }
        if (typeof notes !== 'string' || notes.trim() === '') {
          logger.warn("submitLog (HTTP): Notes cannot be empty.", { userId });
          // Send 400 Bad Request
          response.status(400).json({ success: false, error: 'Notes cannot be empty.', code: 'empty-notes' });
          return;
        }
  
        // --- Fetch User's Weekly Settings ---
        const userSettingsRef = db.collection('users').doc(userId);
        const userSettingsSnap = await userSettingsRef.get();
  
        if (!userSettingsSnap.exists || !userSettingsSnap.data()?.weeklySettings) {
          logger.warn(`submitLog (HTTP): User ${userId} submitted log, but weeklySettings not found.`);
          // Send 412 Precondition Failed (or 400 Bad Request)
          response.status(412).json({ success: false, error: 'Please set your weekly goals using /exp before logging.', code: 'no-weekly-settings' });
          return;
        }
        const settings = userSettingsSnap.data().weeklySettings;
  
        // Helper to check if a setting object is validly configured
        const isConfigured = (setting) => setting && typeof setting.label === 'string' && setting.label.trim() !== "" && typeof setting.unit === 'string' && setting.goal !== null && !isNaN(parseFloat(setting.goal));
  
        // --- Validate Overall Settings Structure ---
        if (!isConfigured(settings.input1) || !isConfigured(settings.output)) {
          logger.error(`submitLog (HTTP): User ${userId} has invalid/incomplete required weeklySettings (Input 1 or Output):`, settings);
          // Send 500 Internal Server Error (as settings seem corrupted server-side)
          response.status(500).json({ success: false, error: 'Your core weekly settings (Input 1 or Output) appear corrupted or incomplete. Please run /exp again.', code: 'corrupted-settings' });
          return;
        }
  
        // --- Validate and Parse Logged Values ---
        const parsedAndLoggedInputs = [];
  
        // Process Input 1 (Required)
        if (inputValues[0] === null || String(inputValues[0]).trim() === '') {
          response.status(400).json({ success: false, error: `Value for Input 1 (${settings.input1.label}) is required.`, code: 'missing-input1'}); return;
        }
        const parsedVal1 = parseFloat(inputValues[0]);
        if (isNaN(parsedVal1)) {
          response.status(400).json({ success: false, error: `Value for Input 1 (${settings.input1.label}) must be a number. You entered: "${inputValues[0]}"`, code: 'nan-input1'}); return;
        }
        // Include goal for potential analysis later
        parsedAndLoggedInputs.push({ label: settings.input1.label, unit: settings.input1.unit, value: parsedVal1, goal: settings.input1.goal });
  
        // Process Input 2 (Required if configured)
        if (isConfigured(settings.input2)) { // Check if setting exists
            if (inputValues[1] === null || String(inputValues[1]).trim() === '') {
            // This error should ideally be caught by Discord's modal validation due to the frontend change.
            // However, having a server-side check is good practice.
            response.status(400).json({ success: false, error: `Value for Input 2 (${settings.input2.label}) is required because it was configured in /exp. You cannot leave it blank.`, code: 'missing-configured-input2'}); return;
            }
            const parsedVal2 = parseFloat(inputValues[1]);
            if (isNaN(parsedVal2)) {
            response.status(400).json({ success: false, error: `Value for Input 2 (${settings.input2.label}) must be a number. You entered: "${inputValues[1]}"`, code: 'nan-input2'}); return;
            }
            parsedAndLoggedInputs.push({ label: settings.input2.label, unit: settings.input2.unit, value: parsedVal2, goal: settings.input2.goal });
        }

  
        // Process Input 3 (Required if configured)
        if (isConfigured(settings.input3)) { // Check if setting exists
            if (inputValues[2] === null || String(inputValues[2]).trim() === '') {
            // This error should ideally be caught by Discord's modal validation.
            response.status(400).json({ success: false, error: `Value for Input 3 (${settings.input3.label}) is required because it was configured in /exp. You cannot leave it blank.`, code: 'missing-configured-input3'}); return;
            }
            const parsedVal3 = parseFloat(inputValues[2]);
            if (isNaN(parsedVal3)) {
            response.status(400).json({ success: false, error: `Value for Input 3 (${settings.input3.label}) must be a number. You entered: "${inputValues[2]}"`, code: 'nan-input3'}); return;
            }
            parsedAndLoggedInputs.push({ label: settings.input3.label, unit: settings.input3.unit, value: parsedVal3, goal: settings.input3.goal });
        }
        // If not configured, this block is skipped.
  
        // Validate and Parse Output Value (Required)
        if (outputValue === null || String(outputValue).trim() === '') {
            response.status(400).json({ success: false, error: `Value for Output (${settings.output.label}) is required and cannot be empty.`, code: 'missing-output'}); return;
        }
        const parsedOutputValue = parseFloat(outputValue);
        if (isNaN(parsedOutputValue)) {
          response.status(400).json({ success: false, error: `Value for Output (${settings.output.label}) must be a number. You entered: "${outputValue}"`, code: 'nan-output'}); return;
        }
        // Add specific output validation if needed (e.g., must be >= 0)
        // Example: if (parsedOutputValue < 0 && settings.output.label.toLowerCase() === 'satisfaction') {
        //   response.status(400).json({ success: false, error: `Value for Satisfaction must be 0 or greater.`, code: 'invalid-satisfaction'}); return;
        // }
  
  
        // --- Prepare Firestore Log Document Data ---
        const logEntry = {
          userId: userId,
          userTag: userTag, // Use tag derived from token
          timestamp: FieldValue.serverTimestamp(), // Ensure FieldValue is imported
          logDate: new Date().toISOString().split('T')[0],
          inputs: parsedAndLoggedInputs, // Contains successfully parsed AND logged inputs including goals
          output: {
            label: settings.output.label,
            unit: settings.output.unit,
            value: parsedOutputValue,
            goal: settings.output.goal // Include goal
          },
          notes: notes.trim(),
          deeperProblem: settings.deeperProblem || "Not set at time of logging" // Include context
        };
  
        // --- Write Log Entry to Firestore ---
        const writeResult = await db.collection('logs').add(logEntry);
        logger.info(`submitLog (HTTP): Successfully submitted log ${writeResult.id} for user ${userId}.`);
  
        // --- Send Success Response ---
        response.status(200).json({ success: true, logId: writeResult.id });
  
      } catch (error) {
        logger.error("submitLog (HTTP): Error during internal logic/Firestore operation for user:", userId, error);
        // Ensure a response is sent for internal errors during logic processing
        if (!response.headersSent) {
          response.status(500).json({ success: false, error: 'Failed to save log entry due to an internal server error.', code: 'internal-server-error-logic' });
        }
      }
    }
  );

/**
 * Calculates and updates the user's streak data.
 */
exports.onLogCreatedUpdateStreak = onDocumentCreated("logs/{logId}", async (event) => {
    const snap = event.data;
    if (!snap) {
        logger.error("No data associated with the event for onLogCreatedUpdateStreak", event);
        return;
    }
    const logData = snap.data();
    const logId = event.params.logId;
    const userId = logData.userId;
    const userTagForMessage = logData.userTag || `User_${userId}`; // For public message

    const logTimestamp = (logData.timestamp && typeof logData.timestamp.toDate === 'function')
                         ? logData.timestamp.toDate() : null;

    if (!userId || !logTimestamp) {
        logger.error("Log document missing valid userId or timestamp for onLogCreatedUpdateStreak.", {
            logId: logId,
            userIdReceived: userId,
            logTimestampValid: !!logTimestamp,
            logData: JSON.stringify(logData)
          });
        return;
    }

    logger.log(`Streak trigger started for user ${userId} (tag: ${userTagForMessage}) due to log ${logId}`);
    const userRef = admin.firestore().collection('users').doc(userId);

    try {
        await admin.firestore().runTransaction(async (transaction) => {
            const userDoc = await transaction.get(userRef);
            let currentData = { streak: 0, longest: 0, freezes: 0, lastLog: null, userTag: userTagForMessage };
            let previousStreak = 0;

            if (userDoc.exists) {
                const userData = userDoc.data();
                previousStreak = userData[STREAK_CONFIG.FIELDS.CURRENT_STREAK] || 0;
                currentData = {
                    streak: previousStreak,
                    longest: userData[STREAK_CONFIG.FIELDS.LONGEST_STREAK] || 0,
                    freezes: Math.min(userData[STREAK_CONFIG.FIELDS.FREEZES_REMAINING] || 0, STREAK_CONFIG.FREEZES.MAX || 5),
                    lastLog: (userData[STREAK_CONFIG.FIELDS.LAST_LOG_TIMESTAMP] && typeof userData[STREAK_CONFIG.FIELDS.LAST_LOG_TIMESTAMP].toDate === 'function')
                             ? userData[STREAK_CONFIG.FIELDS.LAST_LOG_TIMESTAMP].toDate() : null,
                    userTag: userData[STREAK_CONFIG.FIELDS.USER_TAG] || userTagForMessage
                };
                logger.log(`User ${userId} found. Current streak data:`, currentData);
            } else {
                logger.log(`User document ${userId} not found. Initializing streak data.`);
            }

            let newState = {
                newStreak: 1,
                freezesRemaining: currentData.freezes,
                usedFreeze: false,
                streakBroken: false,
                streakContinued: false // True if streak advanced (new day 1, or incremented)
            };

            if (currentData.lastLog instanceof Date && !isNaN(currentData.lastLog)) {
                const hoursSinceLastLog = Math.abs(logTimestamp.getTime() - currentData.lastLog.getTime()) / (1000 * 60 * 60);
                logger.log(`Hours since last log for ${userId}: ${hoursSinceLastLog.toFixed(2)}`);

                if (hoursSinceLastLog < STREAK_CONFIG.TIMING_RULES.SAME_DAY_HOURS) {
                    newState.newStreak = currentData.streak;
                    newState.streakContinued = false; // Not a new streak day
                    logger.log(`Log within ${STREAK_CONFIG.TIMING_RULES.SAME_DAY_HOURS} hours for ${userId}, keeping streak at ${newState.newStreak}.`);
                } else if (hoursSinceLastLog <= STREAK_CONFIG.TIMING_RULES.MAX_CONSECUTIVE_HOURS) {
                    newState.newStreak = currentData.streak + 1;
                    newState.streakContinued = true;
                    logger.log(`Consecutive log for ${userId} (${hoursSinceLastLog.toFixed(2)} hrs), new streak: ${newState.newStreak}`);
                } else {
                   const daysToFreeze = Math.max(0, Math.ceil((hoursSinceLastLog - STREAK_CONFIG.TIMING_RULES.MAX_CONSECUTIVE_HOURS) / 24) + (hoursSinceLastLog > STREAK_CONFIG.TIMING_RULES.MAX_CONSECUTIVE_HOURS ? 0 : -1) );
                   logger.log(`Gap detected for ${userId} (${hoursSinceLastLog.toFixed(2)} hrs). Days needing freeze: ${daysToFreeze}, Freezes available: ${currentData.freezes}`);

                   if (STREAK_CONFIG.FREEZES.AUTO_APPLY && daysToFreeze > 0 && currentData.freezes >= daysToFreeze) {
                       newState.newStreak = currentData.streak + 1;
                       newState.freezesRemaining = currentData.freezes - daysToFreeze;
                       newState.usedFreeze = true;
                       newState.streakContinued = true;
                       logger.log(`Used ${daysToFreeze} freeze(s) for ${userId}. Remaining: ${newState.freezesRemaining}. New streak: ${newState.newStreak}`);
                   } else {
                       newState.newStreak = 1;
                       newState.streakBroken = true; // Explicitly mark as broken
                       newState.streakContinued = true; // Started a new streak day 1
                       logger.log(`Streak reset for ${userId}. New streak: ${newState.newStreak}. Freezes remaining: ${newState.freezesRemaining}`);
                   }
                }
            } else { // First log ever
                newState.newStreak = 1;
                newState.streakContinued = true;
                logger.log(`First log for user ${userId}. New streak: ${newState.newStreak}`);
            }

            // --- Prepare data for Firestore update ---
            const updateData = {
                [STREAK_CONFIG.FIELDS.CURRENT_STREAK]: newState.newStreak,
                [STREAK_CONFIG.FIELDS.LONGEST_STREAK]: Math.max(currentData.longest, newState.newStreak),
                [STREAK_CONFIG.FIELDS.LAST_LOG_TIMESTAMP]: logData.timestamp,
                [STREAK_CONFIG.FIELDS.FREEZES_REMAINING]: newState.freezesRemaining,
                [STREAK_CONFIG.FIELDS.USER_TAG]: logData.userTag || currentData.userTag, // Persist userTag
                // Always update the freeze role based on the new count
                [STREAK_CONFIG.FIELDS.PENDING_FREEZE_ROLE_UPDATE]: `${STREAK_CONFIG.MILESTONES.FREEZE_ROLE_BASENAME}: ${newState.freezesRemaining}`
            };

            // --- Milestone, DM, Public Message, and Role Cleanup Logic ---
        let roleInfo = null;
        let dmMessageText = null;
        let tempPublicMessage = null;
        let needsRoleCleanupForPublicMessage = false;

        // ***** START OF MODIFIED LOGIC FOR DAY 1 WELCOME *****
        const isTrueFirstDay = (isNewUser || previousStreak === 0) && newState.newStreak === 1 && !newState.streakBroken;

        if (isTrueFirstDay) {
            logger.log(`[onLogCreatedUpdateStreak] User ${userId} is on their TRUE Day 1. Preparing welcome messages.`);
            dmMessageText = `🎉 Welcome to your habit tracking journey, ${userTagForMessage}! ` +
                            `You've just logged Day 1 of your streak for the first time (or first time in a while). That's awesome! ` +
                            `Keep it up! You've also earned the 'Originator' role. 🔥`;

            tempPublicMessage = `🎉 Please welcome @${userTagForMessage} to their habit tracking journey! ` +
                                `They've just logged Day 1! Show some support! 🚀`;

            // Assign 'Originator' role
            const firstRole = STREAK_CONFIG.MILESTONES.ROLES.find(role => role.days === 1);
            if (firstRole) {
                roleInfo = { name: firstRole.name, color: firstRole.color, days: firstRole.days };
            }
            // No role cleanup needed for a true first day, as they have no prior streak roles.
            needsRoleCleanupForPublicMessage = false;

        } else if (newState.streakBroken && newState.newStreak === 1) {
            // This is the existing streak reset logic
            dmMessageText = STREAK_CONFIG.MESSAGES.DM.STREAK_RESET;
            tempPublicMessage = STREAK_CONFIG.MESSAGES.PUBLIC.STREAK_RESET.replace('${userTag}', userTagForMessage);
            needsRoleCleanupForPublicMessage = true;
            const firstRole = STREAK_CONFIG.MILESTONES.ROLES.find(role => role.days === 1);
            if (firstRole) {
                roleInfo = { name: firstRole.name, color: firstRole.color, days: firstRole.days };
                logger.log(`Streak reset: Assigning default role ${firstRole.name} and flagging role cleanup.`);
            }
        } else {
            // Existing logic for continued streaks, milestone roles, and streak extensions
            if ((newState.newStreak > previousStreak) || (previousStreak === 0 && newState.newStreak === 1)) { // Catches regular first day if not caught by isTrueFirstDay
                const milestoneRole = STREAK_CONFIG.MILESTONES.ROLES.find(role => role.days === newState.newStreak);
                if (milestoneRole) {
                    roleInfo = { name: milestoneRole.name, color: milestoneRole.color, days: milestoneRole.days };
                    if (!dmMessageText) { // Avoid overwriting Day 1 welcome or reset DM
                       dmMessageText = STREAK_CONFIG.MESSAGES.DM.ROLE_ACHIEVEMENT.replace('${roleName}', roleInfo.name);
                    }
                    logger.log(`User ${userId} hit role milestone: ${roleInfo.name} at ${newState.newStreak} days.`);
                    // Public message for role achievement (if not a streak break and not Day 1 welcome)
                    if (roleInfo.days > 1 && !newState.streakBroken && !isTrueFirstDay) {
                         tempPublicMessage = `🎉 Big congrats to ${userTagForMessage} for achieving the '${roleInfo.name}' title with a ${newState.newStreak}-day streak!`;
                    }
                }
            }
            // Streak extension public message (if no specific role milestone and not Day 1 welcome)
            if (!tempPublicMessage && newState.streakContinued && newState.newStreak > previousStreak && !newState.streakBroken && !roleInfo && !isTrueFirstDay) {
                tempPublicMessage = `🥳 ${userTagForMessage} just extended their streak to ${newState.newStreak} days! Keep it up!`;
            }
        }
        // ***** END OF MODIFIED LOGIC FOR DAY 1 WELCOME *****

        // --- Freeze Award Logic ---
        // This should trigger if the streak has increased or just started, and it's a freeze award day,
        // and a freeze wasn't just used to save the streak.
        if ((newState.newStreak > previousStreak || (previousStreak === 0 && newState.newStreak > 0)) &&
            STREAK_CONFIG.MILESTONES.FREEZE_AWARD_DAYS.includes(newState.newStreak) &&
            !newState.usedFreeze) {
            const maxFreezes = STREAK_CONFIG.FREEZES.MAX || 5;
            // Check current freezes BEFORE awarding a new one.
            // newState.freezesRemaining at this point reflects freezes *after* any potential use to save the streak.
            // We need to compare based on the count *before* awarding this new one.
            // The updateData for FREEZES_REMAINING will directly use the final newState.freezesRemaining.

            if (updateData[STREAK_CONFIG.FIELDS.FREEZES_REMAINING] < maxFreezes) { // Check against the already prepared updateData
                updateData[STREAK_CONFIG.FIELDS.FREEZES_REMAINING]++; // Award freeze directly in updateData
                
                // Update the PENDING_FREEZE_ROLE_UPDATE again with the new count
                updateData[STREAK_CONFIG.FIELDS.PENDING_FREEZE_ROLE_UPDATE] = `${STREAK_CONFIG.MILESTONES.FREEZE_ROLE_BASENAME}: ${updateData[STREAK_CONFIG.FIELDS.FREEZES_REMAINING]}`;
                logger.log(`Awarded freeze to ${userId} at streak ${newState.newStreak}. New total: ${updateData[STREAK_CONFIG.FIELDS.FREEZES_REMAINING]}`);

                const freezeAwardMsg = STREAK_CONFIG.MESSAGES.DM.FREEZE_AWARD.replace('${streak}', newState.newStreak);
                dmMessageText = dmMessageText ? `${dmMessageText}\n\n${freezeAwardMsg}` : freezeAwardMsg;
            } else {
                logger.log(`User ${userId} hit freeze award day ${newState.newStreak}, but already has max freezes (${maxFreezes}). Current in updateData: ${updateData[STREAK_CONFIG.FIELDS.FREEZES_REMAINING]}`);
            }
        }

        // --- Your DEBUG LOGS (keep them here) ---
        logger.log(`[onLogCreatedUpdateStreak DEBUG] For User: ${userId} - previousStreak: ${previousStreak}, newState.newStreak: ${newState.newStreak}, streakContinued (calc'd in func): ${newState.streakContinued}, streakBroken: ${newState.streakBroken}`);
        const debugMilestoneRole = STREAK_CONFIG.MILESTONES.ROLES.find(role => role.days === newState.newStreak);
        logger.log("[onLogCreatedUpdateStreak DEBUG] debugMilestoneRole found (based on newState.newStreak):", debugMilestoneRole);
        logger.log("[onLogCreatedUpdateStreak DEBUG] roleInfo before final assignment logic:", roleInfo);
        // --- End DEBUG LOGS ---

        // --- Determine PENDING_PUBLIC_MESSAGE ---
        if (newState.streakBroken && newState.newStreak === 1) {
            tempPublicMessage = STREAK_CONFIG.MESSAGES.PUBLIC.STREAK_RESET.replace('${userTag}', userTagForMessage);
            needsRoleCleanupForPublicMessage = true; // A streak reset to 1 always implies role cleanup for public view
            logger.log(`[onLogCreatedUpdateStreak] Condition for Public Message: Streak Reset. Message: "${tempPublicMessage}"`);
        } else if (roleInfo && roleInfo.days > 0 && !newState.streakBroken) {
            // This is a role milestone achievement (and not part of a streak break scenario)
            tempPublicMessage = `🎉 Big congrats to ${userTagForMessage} for achieving the '${roleInfo.name}' title with a ${newState.newStreak}-day streak!`;
            logger.log(`[onLogCreatedUpdateStreak] Condition for Public Message: Role Milestone. Message: "${tempPublicMessage}"`);
        } else if (newState.streakContinued && newState.newStreak > previousStreak && !newState.streakBroken && !roleInfo) {
            tempPublicMessage = `🥳 ${userTagForMessage} just extended their streak to ${newState.newStreak} days! Keep it up!`;
            logger.log(`[onLogCreatedUpdateStreak] Condition for Public Message: Streak Extension. Message: "${tempPublicMessage}"`);
        } else {
            logger.log(`[onLogCreatedUpdateStreak] No specific public message condition met. Streak: ${newState.newStreak}, Broken: ${newState.streakBroken}, Continued: ${newState.streakContinued}, RoleInfo: ${roleInfo ? roleInfo.name : 'None'}`);
        }

        // --- Prepare data for Firestore update (add/modify these in your existing updateData object) ---

        // PENDING_DM_MESSAGE (Your existing logic for this should be fine, typically set based on dmMessageText)
        if (dmMessageText) { // dmMessageText is from your earlier logic for DMs
            updateData[STREAK_CONFIG.FIELDS.PENDING_DM_MESSAGE] = dmMessageText;
        } else {
            updateData[STREAK_CONFIG.FIELDS.PENDING_DM_MESSAGE] = FieldValue.delete();
        }

        // PENDING_ROLE_UPDATE (This needs to carefully consider streak breaks vs. regular milestones)
        if (newState.streakBroken && newState.newStreak === 1) {
            const firstRole = STREAK_CONFIG.MILESTONES.ROLES.find(role => role.days === 1);
            if (firstRole) {
                updateData[STREAK_CONFIG.FIELDS.PENDING_ROLE_UPDATE] = { name: firstRole.name, color: firstRole.color, days: firstRole.days };
                logger.log(`[onLogCreatedUpdateStreak] Streak broken to 1 day. Ensuring PENDING_ROLE_UPDATE is set for ${firstRole.name}.`);
            } else {
                updateData[STREAK_CONFIG.FIELDS.PENDING_ROLE_UPDATE] = FieldValue.delete(); // Should not happen if Originator exists
            }
        } else if (roleInfo) { // A non-break role milestone was hit
            updateData[STREAK_CONFIG.FIELDS.PENDING_ROLE_UPDATE] = roleInfo;
        } else { // No specific role change for this event (e.g., simple streak extension without milestone)
            updateData[STREAK_CONFIG.FIELDS.PENDING_ROLE_UPDATE] = FieldValue.delete();
        }

        // PENDING_PUBLIC_MESSAGE (Using the tempPublicMessage determined above)
        if (tempPublicMessage) {
            updateData[STREAK_CONFIG.FIELDS.PENDING_PUBLIC_MESSAGE] = tempPublicMessage;
        } else {
            updateData[STREAK_CONFIG.FIELDS.PENDING_PUBLIC_MESSAGE] = FieldValue.delete();
        }

        // PENDING_ROLE_CLEANUP (Using needsRoleCleanupForPublicMessage determined above)
        if (needsRoleCleanupForPublicMessage) {
            updateData[STREAK_CONFIG.FIELDS.PENDING_ROLE_CLEANUP] = true;
        } else {
            updateData[STREAK_CONFIG.FIELDS.PENDING_ROLE_CLEANUP] = FieldValue.delete();
        }

        // PENDING_FREEZE_ROLE_UPDATE (This should already be in your updateData from earlier logic, based on final newState.freezesRemaining)
        // Example: updateData[STREAK_CONFIG.FIELDS.PENDING_FREEZE_ROLE_UPDATE] = `${STREAK_CONFIG.MILESTONES.FREEZE_ROLE_BASENAME}: ${newState.freezesRemaining}`;
        // Ensure this line exists and is correct based on the final freeze count.

        // <<<< END OF THE NEW LOGIC BLOCK >>>>
        

        // Filter out undefined values (FieldValue.delete() handles actual removal)
        // Object.keys(updateData).forEach(key => updateData[key] === undefined && delete updateData[key]); // Not strictly needed if using FieldValue.delete()

        logger.log(`Updating user ${userId} Firestore doc with:`, JSON.parse(JSON.stringify(updateData)));
        transaction.set(userRef, updateData, { merge: true });
        }); // Transaction complete

        logger.log(`Successfully processed streak & milestone update for user ${userId}.`);

    } catch (error) {
        logger.error(`Error running transaction for user ${userId} streak/milestone update:`, error);
        // Consider more robust error handling for triggers if needed.
    }
    return null; // Firestore triggers don't need to return data to the client
});

// Place this revised helper function above updateWeeklySettings in functions/index.js
/**
 * Parses a single priority string "Goal,Unit,Label" into an object.
 * Goal must be a positive rational number. Label length max 45.
 * Throws an HttpsError if validation fails for a non-empty string.
 * @param {string} priorityStr The raw string from the input array.
 * @param {string} fieldName A descriptive name for the field (e.g., "Input 1", "Output") for error messages.
 * @param {boolean} isOptional Indicates if this field can be legitimately empty.
 * @returns {{goal: number, unit: string, label: string} | {isEmpty: true} | null}
 * Object with parsed data if valid and non-empty.
 * {isEmpty: true} if isOptional and priorityStr is empty.
 * Throws HttpsError otherwise.
 */
function parseAndValidatePriority(priorityStr, fieldName, isOptional = false) {
    const trimmedStr = (priorityStr && typeof priorityStr === 'string') ? priorityStr.trim() : "";

    if (!trimmedStr) {
      if (isOptional) {
        return { isEmpty: true }; // Valid empty state for optional fields
      } else {
        throw new HttpsError('invalid-argument', `Setting for ${fieldName} cannot be empty.`);
      }
    }

    // Regex updated to only use comma as a separator:
    // ^(.*?)      - Capture Group 1 (Goal): Non-greedy, any characters up to the first comma.
    // \s*,\s* - Separator 1: A comma, with optional whitespace.
    // (.*?)      - Capture Group 2 (Unit): Non-greedy, any characters up to the second comma.
    // \s*,\s* - Separator 2: A comma, with optional whitespace.
    // (.+)$       - Capture Group 3 (Label): Any characters until the end.
    const priorityPattern = /^(.*?)\s*,\s*(.*?)\s*,\s*(.+)$/; // MODIFIED REGEX
    const match = trimmedStr.match(priorityPattern);

    if (!match) {
      throw new HttpsError(
        'invalid-argument',
        `${fieldName} ("${trimmedStr}") must be in "Goal #, Unit, Label" format. Use a comma as separator (e.g., "15.5, minutes, meditation" or "10, pages, Reading"). Note: Decimals in goals are fine.`
      );
    }

    const goalStr = match[1].trim();
    const unit = match[2].trim();
    const label = match[3].trim();

    if (!goalStr || !unit || !label) {
      // This case should ideally be caught by the main regex, but as a fallback:
      throw new HttpsError(
        'invalid-argument',
        `${fieldName} ("${trimmedStr}") must be in "Goal #, Unit, Label" format. Use a comma as separator (e.g., "15.5, minutes, meditation" or "10, pages, Reading").`
      );
    }

    // Validate Goal Number (allows decimals)
    const goal = parseFloat(goalStr);
    if (isNaN(goal)) {
      throw new HttpsError(
        'invalid-argument',
        `Goal for ${fieldName} ("${goalStr}") must be a number (e.g., 15 or 8.5).`
      );
    }
    if (goal < 0) {
      throw new HttpsError(
        'invalid-argument',
        `Goal for ${fieldName} ("${goalStr}") must be 0 or a positive number.`
      );
    }

    // Validate Label Length
    const MAX_LABEL_LENGTH = 45; // As per previous discussions
    if (label.length > MAX_LABEL_LENGTH) {
      throw new HttpsError(
        'invalid-argument',
        `Label for ${fieldName} ("${label}") must be ${MAX_LABEL_LENGTH} characters or less.`
      );
    }
    // Unit length validation can be added if needed.

    return { goal: goal, unit: unit, label: label };
}
  
/**
 * Updates the weekly experiment settings for the authenticated user in Firestore.
 * Input 1 and Output are required. Inputs 2 and 3 are optional.
 * Expects data payload: {
 * inputSettings: ["Goal1.Unit1.Label1", "OptGoal2.OptUnit2.OptLabel2", "OptGoal3.OptUnit3.OptLabel3"], // Optional ones can be empty strings
 * outputSetting: "Goal_out.Unit_out.Label_out"
 * }
 */
exports.updateWeeklySettings = onCall(async (request) => {
    if (!request.auth) {
      logger.warn("updateWeeklySettings called without authentication.");
      throw new HttpsError('unauthenticated', 'You must be logged in to update your weekly settings.');
    }
  
    const userId = request.auth.uid;
    const { deeperProblem, inputSettings, outputSetting } = request.data; // Expect 'deeperProblem'
    logger.log(`updateWeeklySettings called by user: ${userId} for problem: "${deeperProblem}"`);
  
    // Validate 'deeperProblem'
    if (typeof deeperProblem !== 'string' || deeperProblem.trim() === '') {
      throw new HttpsError('invalid-argument', 'The "Deeper Problem" statement cannot be empty.');
    }
    // Optional: Add length check for deeperProblem
    const MAX_PROBLEM_LENGTH = 500; // Example
    if (deeperProblem.trim().length > MAX_PROBLEM_LENGTH) {
      throw new HttpsError('invalid-argument', `The "Deeper Problem" statement is too long (max ${MAX_PROBLEM_LENGTH} chars).`);
    }
  
    if (!Array.isArray(inputSettings) || inputSettings.length !== 3) {
      throw new HttpsError('invalid-argument', 'Invalid input: `inputSettings` must be an array of 3 strings.');
    }
    if (!outputSetting || typeof outputSetting !== 'string' || outputSetting.trim() === '') {
      throw new HttpsError('invalid-argument', 'Invalid input: The `outputSetting` string is required and cannot be empty.');
    }
  
    const EMPTY_SETTING = { goal: null, unit: "", label: "" };
    let parsedInput1, parsedInput2, parsedInput3, parsedOutput;
  
    try {
      parsedOutput = parseAndValidatePriority(outputSetting, "Output Metric", false);
      parsedInput1 = parseAndValidatePriority(inputSettings[0], "Input 1", false);
      const tempInput2 = parseAndValidatePriority(inputSettings[1], "Input 2", true);
      parsedInput2 = tempInput2.isEmpty ? EMPTY_SETTING : tempInput2;
      const tempInput3 = parseAndValidatePriority(inputSettings[2], "Input 3", true);
      parsedInput3 = tempInput3.isEmpty ? EMPTY_SETTING : tempInput3;
    } catch (error) {
      logger.warn(`Validation failed for user ${userId} during /experiment settings: ${error.message}`);
      throw error;
    }
  
    const weeklySettingsData = {
      deeperProblem: deeperProblem.trim(), // Store the deeper problem
      output: parsedOutput,
      input1: parsedInput1,
      input2: parsedInput2,
      input3: parsedInput3,
      lastUpdated: FieldValue.serverTimestamp()
      // No experimentStartDate/EndDate yet in this phase
    };
  
    try {
      const db = admin.firestore();
      const userDocRef = db.collection('users').doc(userId);
      await userDocRef.set({ weeklySettings: weeklySettingsData }, { merge: true });
      logger.log(`Successfully updated weekly settings for user ${userId}:`, weeklySettingsData);
  
      const formatSettingForMessage = (setting, name) => {
        if (setting.label) { // Check if it's a configured setting (not an EMPTY_SETTING's label)
          return `${name}: "${setting.label}" (Goal: ${setting.goal} ${setting.unit})`;
        }
        return `${name}: Not set`;
      };
      
      const message = `✅ Experiment settings saved!\n\n🎯 Deeper Problem: "${weeklySettingsData.deeperProblem}"\n📊 Output: "${parsedOutput.label}" (Goal: ${parsedOutput.goal} ${parsedOutput.unit})\n\n${formatSettingForMessage(parsedInput1, "Input 1")}\n${formatSettingForMessage(parsedInput2, "Input 2")}\n${formatSettingForMessage(parsedInput3, "Input 3")}\n\nThese will now appear in your /log form.`;
      
      return { success: true, message: message };
  
    } catch (error) {
      logger.error("Error writing weekly settings to Firestore for user:", userId, error);
      throw new HttpsError('internal', 'Could not save experiment settings due to a server error.', error.message);
    }
  });

  // Add this below the updateWeeklySettings function in functions/index.js
/*
 * Retrieves the weekly experiment settings for the authenticated user from Firestore.
 * Includes detailed logging for performance analysis.
 */
exports.getWeeklySettings = onCall({ minInstances: 1 }, async (request) => {
  const functionStartTime = Date.now();
  // Use request.auth.uid if available, otherwise provide a placeholder for logging if auth is not present
  const loggingUserId = request.auth ? request.auth.uid : "UNKNOWN_USER_NO_AUTH";
  logger.log(`[getWeeklySettings] Invoked by User: ${loggingUserId}. Start Time: ${functionStartTime}`);

  if (!request.auth) {
    logger.warn(`[getWeeklySettings] User: ${loggingUserId} - Called without authentication.`);
    throw new HttpsError(
      'unauthenticated',
      'You must be logged in to get your weekly settings.'
    );
  }

  const userId = request.auth.uid; // Now we know request.auth exists
  logger.log(`[getWeeklySettings] User: ${userId} - Authenticated. Proceeding to fetch settings.`);

  try {
    const db = admin.firestore();
    const userDocRef = db.collection('users').doc(userId);

    const firestoreReadStartTime = Date.now();
    logger.log(`[getWeeklySettings] User: ${userId} - Attempting Firestore read for 'users/${userId}'. Read Start Time: ${firestoreReadStartTime} (Delta from function start: ${firestoreReadStartTime - functionStartTime}ms)`);

    const userDocSnap = await userDocRef.get();

    const firestoreReadEndTime = Date.now();
    logger.log(`[getWeeklySettings] User: ${userId} - Firestore read for 'users/${userId}' completed. Exists: ${userDocSnap.exists}. Duration: ${firestoreReadEndTime - firestoreReadStartTime}ms. Read End Time: ${firestoreReadEndTime} (Delta from function start: ${firestoreReadEndTime - functionStartTime}ms)`);

    let settingsToReturn = null;
    if (!userDocSnap.exists) {
      logger.log(`[getWeeklySettings] User: ${userId} - User document 'users/${userId}' not found.`);
    } else {
      const userData = userDocSnap.data();
      if (userData && userData.weeklySettings && typeof userData.weeklySettings === 'object') {
        logger.log(`[getWeeklySettings] User: ${userId} - Found weeklySettings in document.`);
        settingsToReturn = userData.weeklySettings;
      } else {
        logger.log(`[getWeeklySettings] User: ${userId} - User document 'users/${userId}' exists but has no 'weeklySettings' field or it's not an object.`);
      }
    }

    const functionEndTime = Date.now();
    logger.log(`[getWeeklySettings] User: ${userId} - Successfully completed. Total Duration: ${functionEndTime - functionStartTime}ms. End Time: ${functionEndTime}`);
    return { settings: settingsToReturn };

  } catch (error) {
    const errorTime = Date.now();
    // Log the error with more details including the stack trace
    logger.error(`[getWeeklySettings] User: ${userId} - Error: ${error.message}. Error Occurred At: ${errorTime} (Delta from function start: ${errorTime - functionStartTime}ms)`, {
        errorMessage: error.message,
        errorStack: error.stack, // Important for debugging
        userId: userId
    });
    // Re-throw as HttpsError for the client
    throw new HttpsError(
      'internal', // Or a more specific error code if applicable
      'Could not retrieve weekly settings due to a server error.',
      error.message // Pass the original error message for context if needed by client
    );
  }
});

 /**
 * Clears pending action flags from a user's Firestore document.
 * Called by the Discord bot after it has processed role updates, DMs, etc.
 * Expects no specific data payload, uses authentication context.
 */
exports.clearPendingUserActions = onCall(async (request) => {
    // 1. Check Authentication
    if (!request.auth) {
      logger.warn("clearPendingUserActions called without authentication.");
      throw new HttpsError(
        'unauthenticated',
        'You must be logged in to clear pending actions.'
      );
    }
  
    // 2. Get User ID
    const userId = request.auth.uid;
    logger.log(`clearPendingUserActions called by authenticated user: ${userId}`);
  
    // 3. Access Firestore
    const db = admin.firestore();
    const userRef = db.collection('users').doc(userId);
  
    try {
      // 4. Prepare data to remove pending fields
      // We use FieldValue.delete() to remove the fields from the document.
      // This list should match all "pending" fields set by onLogCreatedUpdateStreak.
      const updatesToClear = {
        [STREAK_CONFIG.FIELDS.PENDING_ROLE_UPDATE]: FieldValue.delete(),
        [STREAK_CONFIG.FIELDS.PENDING_DM_MESSAGE]: FieldValue.delete(),
        [STREAK_CONFIG.FIELDS.PENDING_FREEZE_ROLE_UPDATE]: FieldValue.delete(),
        [STREAK_CONFIG.FIELDS.PENDING_ROLE_CLEANUP]: FieldValue.delete(),
        [STREAK_CONFIG.FIELDS.PENDING_PUBLIC_MESSAGE]: FieldValue.delete()
      };
  
      // 5. Update the user document
      await userRef.update(updatesToClear);
      logger.log(`Successfully cleared pending actions for user ${userId}.`);
  
      return { success: true, message: "Pending actions cleared." };
  
    } catch (error) {
      logger.error("Error clearing pending actions for user:", userId, error);
      // Check if the error is because the document or fields don't exist,
      // which might be okay (e.g., if called twice or if no actions were pending).
      if (error.code === 5) { // Firestore 'NOT_FOUND' error code for .update() on non-existent doc
        logger.warn(`User document ${userId} not found while trying to clear pending actions. Assuming no actions to clear or document was deleted.`);
        return { success: true, message: "No actions to clear or user document not found." };
      }
      throw new HttpsError(
        'internal',
        'Could not clear pending actions due to a server error.',
        error.message
      );
    }
  });

  // Add this function for the /leaderboard command

/**
 * Retrieves leaderboard data (top 10 users by current streak) and
 * the requesting user's rank if they are not in the top 10.
 * Expects no specific data payload, uses authentication context.
 */
exports.getLeaderboard = onCall(async (request) => {
    // 1. Check Authentication
    if (!request.auth) {
      logger.warn("getLeaderboard called without authentication.");
      throw new HttpsError(
        'unauthenticated',
        'You must be logged in to view the leaderboard.'
      );
    }
    const requestingUserId = request.auth.uid;
    logger.log(`getLeaderboard called by authenticated user: ${requestingUserId}`);
  
    // 2. Access Firestore
    const db = admin.firestore();
    const usersCollection = db.collection('users');
  
    try {
      // 3. Fetch Top 10 Users by Current Streak
        const leaderboardQuery = usersCollection
      .orderBy(STREAK_CONFIG.FIELDS.CURRENT_STREAK, 'desc') // Primary sort: highest streak first
      .orderBy(STREAK_CONFIG.FIELDS.LAST_LOG_TIMESTAMP, 'asc') // Secondary sort: earliest timestamp first for ties
      .where(STREAK_CONFIG.FIELDS.CURRENT_STREAK, '>', 0) // Only users with active streaks
      .limit(10);
  
      const leaderboardSnapshot = await leaderboardQuery.get();
      const top10Users = [];
      leaderboardSnapshot.forEach(doc => {
        const userData = doc.data();
        top10Users.push({
          userId: doc.id,
          userTag: userData[STREAK_CONFIG.FIELDS.USER_TAG] || `User_${doc.id}`,
          currentStreak: userData[STREAK_CONFIG.FIELDS.CURRENT_STREAK]
        });
      });
  
      // 4. Fetch All Users' Streaks to Determine Ranks (if necessary)
      //    and the requesting user's data if not in top 10.
      let requestingUserInfo = null;
      let userIsInTop10 = top10Users.some(user => user.userId === requestingUserId);
  
      if (!userIsInTop10 || top10Users.length === 0) { // Fetch all if user not in top 10 or if top 10 is empty (to get user's rank)
        const allActiveUsersQuery = usersCollection
        .where(STREAK_CONFIG.FIELDS.CURRENT_STREAK, '>', 0)
        .orderBy(STREAK_CONFIG.FIELDS.CURRENT_STREAK, 'desc') // Primary sort
        .orderBy(STREAK_CONFIG.FIELDS.LAST_LOG_TIMESTAMP, 'asc'); // Secondary sort for accurate ranking

        const allActiveUsersSnapshot = await allActiveUsersQuery.get();
          
          let rank = 0;
          let foundUser = false;
          allActiveUsersSnapshot.forEach(doc => {
              rank++;
              if (doc.id === requestingUserId) {
                  const userData = doc.data();
                  requestingUserInfo = {
                      userId: doc.id,
                      userTag: userData[STREAK_CONFIG.FIELDS.USER_TAG] || `User_${doc.id}`,
                      currentStreak: userData[STREAK_CONFIG.FIELDS.CURRENT_STREAK],
                      rank: rank,
                      totalActive: allActiveUsersSnapshot.size
                  };
                  foundUser = true;
              }
          });
          // If user has 0 streak, they won't be in allActiveUsersSnapshot
          if (!foundUser) {
              const userDoc = await usersCollection.doc(requestingUserId).get();
              if (userDoc.exists) {
                   const userData = userDoc.data();
                   requestingUserInfo = {
                       userId: requestingUserId,
                       userTag: userData[STREAK_CONFIG.FIELDS.USER_TAG] || `User_${requestingUserId}`,
                       currentStreak: userData[STREAK_CONFIG.FIELDS.CURRENT_STREAK] || 0,
                       rank: userData[STREAK_CONFIG.FIELDS.CURRENT_STREAK] > 0 ? allActiveUsersSnapshot.size + 1 : 0, // Rank 0 or N/A if no streak
                       totalActive: allActiveUsersSnapshot.size
                   };
              } else { // User document doesn't exist
                   requestingUserInfo = {
                       userId: requestingUserId,
                       userTag: request.auth.token?.name || `User_${requestingUserId}`, // Fallback userTag
                       currentStreak: 0,
                       rank: 0,
                       totalActive: allActiveUsersSnapshot.size
                   };
              }
          }
      }
  
  
      // 5. Format the response for the bot
      let messageLines = ["🏆 **Streak Leaderboard** 🏆\n"];
      if (top10Users.length === 0) {
        messageLines.push("No active streaks on the leaderboard yet. Be the first!");
      } else {
        top10Users.forEach((user, index) => {
          messageLines.push(`${index + 1}. ${user.userTag} - ${user.currentStreak} days`);
        });
      }
  
      // Add requesting user's info if not in top 10 and has a streak or if leaderboard is empty
      if (requestingUserInfo && !userIsInTop10 && requestingUserInfo.currentStreak > 0) {
          if (top10Users.length > 0) { // Add separator only if there are top 10 entries
              messageLines.push("--------------------");
          }
          messageLines.push(`Your Rank: #${requestingUserInfo.rank} - ${requestingUserInfo.userTag} - ${requestingUserInfo.currentStreak} days`);
      } else if (requestingUserInfo && requestingUserInfo.currentStreak === 0) {
          if (top10Users.length > 0) {
              messageLines.push("--------------------");
          }
          messageLines.push(`You currently have no active streak, ${requestingUserInfo.userTag}. Start one with /log!`);
      }
  
  
      return {
        success: true,
        message: messageLines.join('\n'),
        leaderboardData: top10Users, // optional: raw data for bot if it wants to format differently
        userData: requestingUserInfo // optional: raw data for requesting user
      };
  
    } catch (error) {
      logger.error("Error fetching leaderboard for user:", requestingUserId, error);
      throw new HttpsError(
        'internal',
        'Could not retrieve leaderboard due to a server error.',
        error.message
      );
    }
  });

  // In functions/index.js

/**
 * Retrieves necessary user data fields for the bot after a log submission.
 * Used to check for pending actions (DMs, roles) set by triggers.
 * Expects no data payload, uses authentication context.
 */
exports.getUserDataForBot = onCall(async (request) => {
    // 1. Check Authentication
    if (!request.auth) {
      logger.warn("getUserDataForBot called without authentication.");
      throw new HttpsError('unauthenticated', 'Authentication required.');
    }
    const userId = request.auth.uid;
    logger.log(`getUserDataForBot called by authenticated user: ${userId}`);
  
    // 2. Access Firestore
    const db = admin.firestore();
    const userRef = db.collection('users').doc(userId);
  
    try {
      const userDoc = await userRef.get();
  
      if (!userDoc.exists) {
        logger.log(`[getUserDataForBot] User document ${userId} not found. Returning default data.`);
        // Return default structure if user doc doesn't exist (shouldn't happen if log was just submitted)
        return { success: true, userData: { userId: userId, currentStreak: 0, longestStreak: 0, freezesRemaining: 0 } };
      }
  
      const firestoreData = userDoc.data();
      // 3. Selectively return only the fields the bot needs
      // This prevents sending unnecessary sensitive data if the user doc grows.
      const userDataForBot = {
        userId: userId,
        userTag: firestoreData[STREAK_CONFIG.FIELDS.USER_TAG] || null,
        currentStreak: firestoreData[STREAK_CONFIG.FIELDS.CURRENT_STREAK] || 0,
        longestStreak: firestoreData[STREAK_CONFIG.FIELDS.LONGEST_STREAK] || 0,
        freezesRemaining: firestoreData[STREAK_CONFIG.FIELDS.FREEZES_REMAINING] || 0,
        // Include all potential pending fields
        pendingDmMessage: firestoreData[STREAK_CONFIG.FIELDS.PENDING_DM_MESSAGE] || null,
        pendingRoleUpdate: firestoreData[STREAK_CONFIG.FIELDS.PENDING_ROLE_UPDATE] || null, // This holds { name, color, days } or null
        pendingFreezeRoleUpdate: firestoreData[STREAK_CONFIG.FIELDS.PENDING_FREEZE_ROLE_UPDATE] || null, // This holds role name e.g., "❄️ Freezes: 2" or null
        pendingRoleCleanup: firestoreData[STREAK_CONFIG.FIELDS.PENDING_ROLE_CLEANUP] || false, // Boolean
        pendingPublicMessage: firestoreData[STREAK_CONFIG.FIELDS.PENDING_PUBLIC_MESSAGE] || null,
      };
  
      logger.log(`[getUserDataForBot] Returning data for ${userId}:`, userDataForBot);
      return { success: true, userData: userDataForBot };
  
    } catch (error) {
      logger.error(`[getUserDataForBot] Error fetching data for user ${userId}:`, error);
      throw new HttpsError('internal', 'Could not retrieve user data.', error.message);
    }
  });

  // Add this new function in functions/index.js

/**
 * Retrieves the current and longest streak for the authenticated user.
 */
// In functions/index.js, modify getStreakData

exports.getStreakData = onCall(async (request) => {
    // 1. Check Authentication
    if (!request.auth) {
      logger.warn("getStreakData called without authentication.");
      throw new HttpsError(
        'unauthenticated',
        'You must be logged in to view your streak.'
      );
    }
    const userId = request.auth.uid;
    logger.log(`getStreakData called by authenticated user: ${userId}`);
  
    // 2. Access Firestore
    const db = admin.firestore();
    const userRef = db.collection('users').doc(userId);
  
    try {
      const userDoc = await userRef.get();
  
      if (!userDoc.exists) {
        logger.log(`[getStreakData] User document ${userId} not found. Returning 0 streaks/freezes.`);
        return {
          success: true,
          currentStreak: 0,
          longestStreak: 0,
          freezesRemaining: 0, // Add this
          message: "You haven't started your streak yet. Use the /log command to begin!"
        };
      }
  
      const userData = userDoc.data();
      const currentStreak = userData[STREAK_CONFIG.FIELDS.CURRENT_STREAK] || 0;
      const longestStreak = userData[STREAK_CONFIG.FIELDS.LONGEST_STREAK] || 0;
      const freezesRemaining = userData[STREAK_CONFIG.FIELDS.FREEZES_REMAINING] || 0; // Get freezes
  
      let message = `🔥Your current streak: ${currentStreak} days\n🧨Your longest streak: ${longestStreak} days\n🧊Streak Freezes: ${freezesRemaining} available`; // Add freezes to message
  
      if (currentStreak === 0 && longestStreak === 0) {
          message = `You haven't started your streak yet. Use the /log command to begin!\nStreak Freezes: ${freezesRemaining} available`;
      } else if (currentStreak === 0 && longestStreak > 0) {
          message = `You currently don't have an active streak. Your longest streak was ${longestStreak} days.\nUse the /log command to start a new one!\nStreak Freezes: ${freezesRemaining} available`;
      }
  
  
      logger.log(`[getStreakData] Returning streak data for ${userId}: Current: ${currentStreak}, Longest: ${longestStreak}, Freezes: ${freezesRemaining}`);
      return {
        success: true,
        currentStreak: currentStreak,
        longestStreak: longestStreak,
        freezesRemaining: freezesRemaining, // Add this to the return object
        message: message
      };
  
    } catch (error) {
      logger.error(`[getStreakData] Error fetching streak data for user ${userId}:`, error);
      throw new HttpsError('internal', 'Could not retrieve streak data.', error.message);
    }
  });


// Add this entire new function to your functions/index.txt file

/**
 * Saves the experiment duration and reminder schedule for the authenticated user.
 * Expects data payload: {
 * experimentDuration: string (e.g., "1_week", "4_weeks"),
 * userCurrentTime: string | null (e.g., "2:30 PM" or "14:30", or null if skipped),
 * reminderWindowStartHour: string | null (e.g., "09" for 9 AM, "17" for 5 PM, or null),
 * reminderWindowEndHour: string | null (e.g., "17" for 5 PM, "00" for midnight, or null),
 * reminderFrequency: string (e.g., "daily_1", "none"),
 * customReminderMessage: string | null (currently expected to be null from bot),
 * skippedReminders: boolean (true if user explicitly skipped reminder setup)
 * }
 */
exports.setExperimentSchedule = onCall(async (request) => {
    if (!request.auth) {
        logger.warn("setExperimentSchedule called without authentication.");
        throw new HttpsError('unauthenticated', 'You must be logged in to set an experiment schedule.');
    }

    const userId = request.auth.uid;
    const data = request.data;

    logger.log(`setExperimentSchedule called by user: ${userId} with data:`, data);

    // --- Validate Input Data ---
    if (!data.experimentDuration || typeof data.experimentDuration !== 'string') {
        throw new HttpsError('invalid-argument', 'Experiment duration is required and must be a string.');
    }
    if (typeof data.skippedReminders !== 'boolean') {
        throw new HttpsError('invalid-argument', 'skippedReminders flag is required and must be a boolean.');
    }

    // If reminders were not skipped, other fields might be expected (though they can be 'none' for frequency)
    if (data.skippedReminders === false) {
        if (data.reminderFrequency === 'none') {
            // If frequency is 'none', other time-related fields are not strictly needed by backend logic
            // but good to ensure they are at least present as null if not 'none'
            if (data.userCurrentTime !== null || data.reminderWindowStartHour !== null || data.reminderWindowEndHour !== null) {
                // This state is a bit contradictory: frequency is 'none' but time details provided.
                // For robustness, we'll proceed but log it. Backend should prioritize 'none'.
                logger.warn(`[setExperimentSchedule] User ${userId} has reminderFrequency 'none' but also provided some time details. Frequency 'none' will take precedence.`, data);
            }
        } else {
            // If frequency is NOT 'none', then current time and window are essential for scheduling.
            if (typeof data.userCurrentTime !== 'string' || data.userCurrentTime.trim() === '') {
                throw new HttpsError('invalid-argument', 'User current time is required when setting active reminders.');
            }
            if (typeof data.reminderWindowStartHour !== 'string' || data.reminderWindowStartHour.trim() === '') {
                throw new HttpsError('invalid-argument', 'Reminder window start hour is required when setting active reminders.');
            }
            if (typeof data.reminderWindowEndHour !== 'string' || data.reminderWindowEndHour.trim() === '') {
                throw new HttpsError('invalid-argument', 'Reminder window end hour is required when setting active reminders.');
            }
            // Potentially add more specific validation for time formats if needed here.
            // For example, check if reminderWindowStartHour and reminderWindowEndHour are valid 24-hour format strings ("00"-"23").
            // The bot-side validation for start < end is good, but backend can double check if critical.
        }
    }

    const experimentScheduleData = {
        experimentDuration: data.experimentDuration,
        experimentSetAt: FieldValue.serverTimestamp(), // Timestamp for when this schedule was set

        // Reminder specific fields
        userCurrentTimeAtSetup: data.skippedReminders ? null : data.userCurrentTime, // Store the user's stated current time
        reminderWindowStartLocal: data.skippedReminders || data.reminderFrequency === 'none' ? null : data.reminderWindowStartHour, // Store as local hour string e.g. "09"
        reminderWindowEndLocal: data.skippedReminders || data.reminderFrequency === 'none' ? null : data.reminderWindowEndHour,   // Store as local hour string e.g. "17"
        reminderFrequency: data.reminderFrequency, // e.g., "daily_1", "none"
        // customReminderMessage: data.customReminderMessage, // Bot currently sends null
        remindersSkipped: data.skippedReminders,

        // Potentially calculate next report date here if needed, or do it client-side/via another trigger
        // For now, just storing the duration.
    };

    try {
        const db = admin.firestore();
        const userDocRef = db.collection('users').doc(userId);

        // We want to store this schedule information likely within the user's document.
        // You might have a subcollection for experiments, or a top-level field.
        // For simplicity, let's assume you're merging it into a 'experimentCurrentSchedule' field.
        await userDocRef.set({
            experimentCurrentSchedule: experimentScheduleData
        }, { merge: true });

        logger.log(`Successfully saved experiment schedule for user ${userId}:`, experimentScheduleData);

        // Construct a success message for the bot
        let message = `✅ Experiment duration set to ${data.experimentDuration.replace('_', ' ')}.`;
        if (data.skippedReminders) {
            message += " Reminders were skipped.";
        } else if (data.reminderFrequency === 'none') {
            message += " No reminders will be sent.";
        } else {
            message += ` Reminders scheduled (frequency: ${data.reminderFrequency.replace('_', ' ')}, window: ${data.reminderWindowStartHour}:00-${data.reminderWindowEndHour}:00 based on your local time).`;
        }

        return { success: true, message: message, scheduleId: userId }; // Or a generated ID if you save to a new doc

    } catch (error) {
        logger.error("Error writing experiment schedule to Firestore for user:", userId, error);
        throw new HttpsError('internal', 'Could not save experiment schedule due to a server error.', error.message);
    }
});
  
// ======================================================================
// REMINDERS FOR DISCORD BOT CODE (Render - bot code index js file.txt)
//
// This section outlines the necessary changes and logic for your
// Discord bot to integrate with the updated Firebase Cloud Functions.
// Review this carefully when implementing bot-side changes.
//
// Current Date: May 7, 2025 // Adjust as needed
// Firebase Functions Updated: Yes (Includes experiment settings, logging,
// streaks, pending actions, leaderboard w/ tie-breaking)
// ======================================================================

// --- Core Setup & Firebase Integration ---
// 1. Firebase Admin SDK (Optional but Recommended for Post-Log Checks):
//    - To reliably fetch `pending...` fields after a log, the bot should ideally use the
//      Firebase Admin SDK (requires service account key securely stored on Render).
//    - ALTERNATIVE: Create a simple Firebase callable function `getUserData()` that fetches
//      and returns the necessary fields from the user's document (`currentStreak`, `longestStreak`,
//      `freezesRemaining`, and all `pending...` fields). The bot calls this after `submitLog` succeeds.
//
// 2. Firebase Callable Function Invocation:
//    - Implement robust calling logic (including error handling) for:
//      - `getFirebaseAuthToken({ userId })`
//      - `updateWeeklySettings({ deeperProblem, outputSetting, inputSettings })`
//      - `getWeeklySettings()`
//      - `submitLog({ inputValues, outputValue, notes })`
//      - `clearPendingUserActions()` // <<< Call this LAST, after processing ALL pending actions.
//      - `getLeaderboard()` // <<< New function for the /leaderboard command.
//    - Manage Firebase authentication state within the bot.

// --- Command Changes & Implementation ---
// 3. Rename /setweek to /experiment:
//    - Update SlashCommandBuilder name and description. Re-register commands.
//
// 4. Implement /experiment Button Hub:
//    - On /experiment command: Send ephemeral message with buttons:
//      - [Review Latest Experiment] (ID: `review_latest_experiment_btn`)
//      - [Set/Update Experiment] (ID: `set_update_experiment_btn`)
//      - [Set Reminders & Duration] (ID: `set_experiment_reminders_btn`)
//
// 5. Implement `set_update_experiment_btn` Handler:
//    - Show Modal (`experiment_setup_modal`).
//    - Fields: `deeper_problem`, `output_setting`, `input1_setting`, `input2_setting`, `input3_setting`.
//    - **Emphasize COMMA as the separator** in field labels/placeholders (e.g., "Output Metric (Goal,Unit,Label):").
//    - On submit, call `updateWeeklySettings` Firebase function. Display result ephemerally.
//
// 6. Implement `review_latest_experiment_btn` Handler (Initial):
//    - Call `getWeeklySettings`. Display results ephemerally. Add "Stats coming soon" text.
//
// 7. Implement `set_experiment_reminders_btn` Handler (Initial):
//    - Reply ephemerally: "Coming soon!".
//
// 8. Update /log Command:
//    - On command run: Call `getWeeklySettings`.
//    - Dynamically build Modal based on *configured* settings (check `settings.inputX.label !== ""`).
//      - Use setting labels/placeholders (`Goal: X Unit`). Mark optional TextInputs as `setRequired(false)`.
//    - If no settings, prompt user to run `/experiment`.
//    - On submit: Call `submitLog` Firebase function with `{ inputValues: [val1, val2_or_"", val3_or_""], outputValue, notes }`.
//
// 9. Implement /leaderboard Command:
//    - On command run: Call `getLeaderboard` Firebase function.
//    - Display the `message` string from the function's response ephemerally.

// --- Post-Log Action Processing (CRITICAL BOT LOGIC) ---
// 10. After `submitLog` Success:
//     - The bot MUST fetch the user's latest data from Firestore (via Admin SDK or a `getUserData` function).
//     - Let the fetched data be `userData`. Check for the existence of the following fields:
//
// 11. Process `pendingDmMessage`:
//     - If `userData.pendingDmMessage` exists: Send it as a DM to the user. Handle DM errors.
//
// 12. Process `pendingFreezeRoleUpdate`:
//     - If `userData.pendingFreezeRoleUpdate` exists (e.g., "❄️ Freezes: 3"):
//       - Get the target role name (e.g., "❄️ Freezes: 3").
//       - Find/Create the target role on the Discord server (`ensureRole`).
//       - Get the user's member object (`interaction.member` or fetch if needed).
//       - Remove any OTHER role on the user starting with "❄️ Freezes:".
//       - Add the target role to the user.
//
// 13. Process `pendingRoleCleanup` and `pendingRoleUpdate`:
//     - Get the user's member object.
//     - If `userData.pendingRoleCleanup === true`:
//       - Get a list of all streak milestone role names (from Originator to Transcendent).
//       - Iterate through the user's current roles. Remove any role whose name matches one in the milestone list *EXCEPT* 'Originator'.
//     - If `userData.pendingRoleUpdate` exists:
//       - Let `newRoleInfo = userData.pendingRoleUpdate`.
//       - Find/Create the role (`ensureRole(guild, newRoleInfo.name, newRoleInfo.color)`).
//       - Add this role to the user.
//       - **Public Message (New Role):** If `userData.pendingRoleCleanup` is NOT true AND `newRoleInfo` is for a milestone beyond day 1, post to channel: `🎊 @user has achieved the ${newRoleInfo.name} title! Show some love!`
//
// 14. Process `pendingPublicMessage`:
//     - If `userData.pendingPublicMessage` exists (this is for the streak reset):
//       - Post this message content to the interaction channel.
//
// 15. *** Call `clearPendingUserActions()` ***:
//     - AFTER attempting all actions in steps 11-14, the bot MUST call the `clearPendingUserActions()` Firebase function to prevent reprocessing.
//
// --- Bot-Side Message Construction ---
// 16. `/log` Confirmation Message:
//     - Define an array `INSPIRATIONAL_MESSAGES` in the bot code.
//     - After `submitLog` success AND fetching `userData` (step 10):
//       - Construct the ephemeral reply/DM including:
//         - Basic confirmation text (e.g., "✅ Log saved!").
//         - A random message from `INSPIRATIONAL_MESSAGES`.
//         - Current Streak: `userData.currentStreak`.
//         - Longest Streak: `userData.longestStreak`.
//         - Freezes Remaining: `userData.freezesRemaining`.
//
// --- Utility Functions Needed in Bot ---
// 17. `ensureRole(guild, roleName, color)`: Handles finding or creating Discord roles.
// 18. List/Mechanism for Streak Milestone Roles: Needed for the role cleanup logic.
//
// --- Dependencies ---
// 19. `discord.js`, `dotenv`, `node-fetch` (already installed).
// 20. `firebase-admin` (if using Admin SDK in bot).
// 21. `date-fns` (optional, for advanced date formatting).
//
// ======================================================================

// Final blank line below this comment
